<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>src.misc.imageio API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>src.misc.imageio</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from pathlib import Path
from typing import Optional, Tuple
from warnings import warn

from utils import StrPath

import numpy as np
import pandas as pd
import PIL.Image
import yaml
from skimage.exposure import rescale_intensity
from skimage.io import imread, imsave

from .tools import uint8_image, uint16_image


class ImageIO:
  META_SUFFIX = &#39;_meta&#39;
  META_EXT = &#39;.yaml&#39;
  CSV_EXT = &#39;.csv&#39;
  NPY_EXT = &#39;.npy&#39;
  XLSX_EXT = &#39;.xlsx&#39;

  ENCODING = &#39;UTF-8-SIG&#39;
  DELIMITER = &#39;,&#39;

  @classmethod
  def meta_path(cls, path: Path) -&gt; Path:
    return path.with_name(f&#39;{path.stem}{cls.META_SUFFIX}{cls.META_EXT}&#39;)

  @classmethod
  def read(cls, path: StrPath) -&gt; np.ndarray:
    &#34;&#34;&#34;
    주어진 path의 확장자에 따라 영상 파일 해석

    Parameters
    ----------
    path : Union[str, Path]
        대상 파일 경로. `.npy`, `.csv`, `.xlsx` 및 `.png` 등 영상 확장자 지정 가능
        (`skimage.io.imread` 참조).

    Returns
    -------
    np.ndarray

    Raises
    ------
    FileNotFoundError
        대상 파일이 존재하지 않을 때
    &#34;&#34;&#34;
    path = Path(path).resolve()
    if not path.exists():
      raise FileNotFoundError(path)

    if path.suffix == cls.NPY_EXT:
      image = np.load(file=path.as_posix())
    elif path.suffix == cls.CSV_EXT:
      image = np.loadtxt(fname=path.as_posix(), delimiter=cls.DELIMITER)
    elif path.suffix == cls.XLSX_EXT:
      image = pd.read_excel(path.as_posix())
      image = np.array(image)
    else:
      image = imread(fname=path.as_posix())

    return image

  @classmethod
  def read_with_meta(cls,
                     path: StrPath,
                     scale=False) -&gt; Tuple[np.ndarray, Optional[dict]]:
    &#34;&#34;&#34;
    주어진 path의 확장자에 따라 영상 파일 및 메타 정보 해석.
    조건에 따라 영상의 픽셀 값을 메타 정보에 기록된 원 범위로 scale함.

    Parameters
    ----------
    path : Union[str, Path]
        대상 파일 경로
    scale : bool, optional
        `True`이며 대상 파일이 영상 확장자 (`.png` 등)인 경우,
        `save_with_meta` 함수로 저장된 메타 정보 파일로부터 읽은
        원본 범위로 픽셀 값을 scale함.

    Returns
    -------
    image : np.ndarray
    meta_data : Optional[dict]
    &#34;&#34;&#34;
    path = Path(path).resolve()
    image = cls.read(path)

    meta_path = cls.meta_path(path)
    if meta_path.exists():
      with open(meta_path, &#39;r&#39;, encoding=cls.ENCODING) as f:
        meta = yaml.safe_load(f)
    else:
      meta = None

    if scale and path.suffix not in (&#39;.csv&#39;, &#39;.npy&#39;):
      if meta is None:
        warn(f&#39;메타 정보 파일 ({meta_path.name})이 존재하지 않습니다. &#39;
             f&#39;영상의 밝기 범위를 변경하지 않습니다.&#39;)
      else:
        try:
          img_range = (meta[&#39;range&#39;][&#39;min&#39;], meta[&#39;range&#39;][&#39;max&#39;])
        except KeyError:
          warn(f&#39;메타 정보 파일 ({meta_path.name})에 영상의 밝기 정보가 없습니다. &#39;
               f&#39;영상의 밝기 범위를 변경하지 않습니다.&#39;)
        else:
          image = rescale_intensity(image=image, out_range=img_range)

    return image, meta

  @classmethod
  def save(cls, path: StrPath, array: np.ndarray, check_contrast=False):
    &#34;&#34;&#34;
    주어진 path의 확장자에 따라 영상 파일 저장

    Parameters
    ----------
    path : Union[str, Path]
        저장 경로. `.npy`, `.csv` 및 `.png` 등 영상 확장자 지정 가능
        (`skimage.io.imsave` 참조).
    array : np.ndarray
        저장할 영상
    check_contrast : bool, optional
        `True`인 경우, 영상 파일 확장자 저장 시 영상의 대비가 너무 낮으면 경고.
    &#34;&#34;&#34;
    path = Path(path).resolve()
    if path.suffix == cls.NPY_EXT:
      np.save(file=path.as_posix(), arr=array)
    elif path.suffix == cls.CSV_EXT:
      np.savetxt(fname=path.as_posix(), X=array, delimiter=cls.DELIMITER)
    else:
      imsave(fname=path.as_posix(), arr=array, check_contrast=check_contrast)

  @staticmethod
  def _scale_and_save(array: np.ndarray, path: Path, exts: list, dtype=&#39;uint8&#39;):
    if not exts:
      return
    if dtype not in (&#39;uint8&#39;, &#39;uint16&#39;):
      raise ValueError

    if dtype == &#39;uint8&#39;:
      image = uint8_image(array)
      for ext in exts:
        imsave(fname=path.with_suffix(ext).as_posix(),
               arr=image,
               check_contrast=False)
    else:
      image = uint16_image(array)
      pil_image = PIL.Image.fromarray(image)

      for ext in exts:
        pil_image.save(fp=path.with_suffix(ext))

  @staticmethod
  def _save_image(array: np.ndarray, path: Path, exts: list):
    for ext in exts:
      imsave(fname=path.with_suffix(ext).as_posix(), arr=array)

  @classmethod
  def save_with_meta(cls,
                     path: StrPath,
                     array: np.ndarray,
                     exts: list,
                     meta: Optional[dict] = None,
                     dtype: Optional[str] = None):
    &#34;&#34;&#34;
    주어진 path와 각 확장자 (`exts`)에 따라 영상 파일 저장.
    조건에 따라 주어진 메타 정보를 함께 저장하며, 영상 확장자 (`.png` 등) 파일은
    영상 파일 형식에 맞게 픽셀 값의 범위를 조정함.

    Parameters
    ----------
    path : Union[str, Path]
        저장 경로 (확장자는 `exts`에 따라 변경함).
    array : np.ndarray
        저장할 영상.
    exts : list
        저장할 확장자 목록.
    meta : Optional[dict], optional
        영상의 메타데이터 (Exif 정보 등). `None`이 아니면 `{file name}_meta.yaml`
        파일에 메타 정보 저장.
    dtype : Optional[str], optional
        None이면 입력한 array를 그대로 영상 확장자로 저장. &#39;uint8&#39; 혹은 &#39;uint16&#39;인
        경우, 해당 dtype의 범위로 정규화하고 저장.
    &#34;&#34;&#34;
    path = Path(path)

    # npy 저장
    if cls.NPY_EXT in exts:
      np.save(file=path.with_suffix(cls.NPY_EXT).as_posix(), arr=array)
      exts.remove(cls.NPY_EXT)

    # csv 저장
    if cls.CSV_EXT in exts:
      np.savetxt(fname=path.with_suffix(cls.CSV_EXT).as_posix(),
                 X=array,
                 delimiter=cls.DELIMITER)
      exts.remove(cls.CSV_EXT)

    # 이미지 파일 저장
    if dtype is None:
      cls._save_image(array=array, path=path, exts=exts)
    else:
      cls._scale_and_save(array=array, path=path, exts=exts, dtype=dtype)

    # 메타 데이터 저장
    if meta is not None:
      meta[&#39;range&#39;] = {
          &#39;min&#39;: np.around(np.nanmin(array).item(), 4).item(),
          &#39;max&#39;: np.around(np.nanmax(array).item(), 4).item()
      }
      meta_path = cls.meta_path(path)
      with open(meta_path, &#39;w&#39;, encoding=cls.ENCODING) as f:
        yaml.safe_dump(meta, f, indent=4, sort_keys=False)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="src.misc.imageio.ImageIO"><code class="flex name class">
<span>class <span class="ident">ImageIO</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ImageIO:
  META_SUFFIX = &#39;_meta&#39;
  META_EXT = &#39;.yaml&#39;
  CSV_EXT = &#39;.csv&#39;
  NPY_EXT = &#39;.npy&#39;
  XLSX_EXT = &#39;.xlsx&#39;

  ENCODING = &#39;UTF-8-SIG&#39;
  DELIMITER = &#39;,&#39;

  @classmethod
  def meta_path(cls, path: Path) -&gt; Path:
    return path.with_name(f&#39;{path.stem}{cls.META_SUFFIX}{cls.META_EXT}&#39;)

  @classmethod
  def read(cls, path: StrPath) -&gt; np.ndarray:
    &#34;&#34;&#34;
    주어진 path의 확장자에 따라 영상 파일 해석

    Parameters
    ----------
    path : Union[str, Path]
        대상 파일 경로. `.npy`, `.csv`, `.xlsx` 및 `.png` 등 영상 확장자 지정 가능
        (`skimage.io.imread` 참조).

    Returns
    -------
    np.ndarray

    Raises
    ------
    FileNotFoundError
        대상 파일이 존재하지 않을 때
    &#34;&#34;&#34;
    path = Path(path).resolve()
    if not path.exists():
      raise FileNotFoundError(path)

    if path.suffix == cls.NPY_EXT:
      image = np.load(file=path.as_posix())
    elif path.suffix == cls.CSV_EXT:
      image = np.loadtxt(fname=path.as_posix(), delimiter=cls.DELIMITER)
    elif path.suffix == cls.XLSX_EXT:
      image = pd.read_excel(path.as_posix())
      image = np.array(image)
    else:
      image = imread(fname=path.as_posix())

    return image

  @classmethod
  def read_with_meta(cls,
                     path: StrPath,
                     scale=False) -&gt; Tuple[np.ndarray, Optional[dict]]:
    &#34;&#34;&#34;
    주어진 path의 확장자에 따라 영상 파일 및 메타 정보 해석.
    조건에 따라 영상의 픽셀 값을 메타 정보에 기록된 원 범위로 scale함.

    Parameters
    ----------
    path : Union[str, Path]
        대상 파일 경로
    scale : bool, optional
        `True`이며 대상 파일이 영상 확장자 (`.png` 등)인 경우,
        `save_with_meta` 함수로 저장된 메타 정보 파일로부터 읽은
        원본 범위로 픽셀 값을 scale함.

    Returns
    -------
    image : np.ndarray
    meta_data : Optional[dict]
    &#34;&#34;&#34;
    path = Path(path).resolve()
    image = cls.read(path)

    meta_path = cls.meta_path(path)
    if meta_path.exists():
      with open(meta_path, &#39;r&#39;, encoding=cls.ENCODING) as f:
        meta = yaml.safe_load(f)
    else:
      meta = None

    if scale and path.suffix not in (&#39;.csv&#39;, &#39;.npy&#39;):
      if meta is None:
        warn(f&#39;메타 정보 파일 ({meta_path.name})이 존재하지 않습니다. &#39;
             f&#39;영상의 밝기 범위를 변경하지 않습니다.&#39;)
      else:
        try:
          img_range = (meta[&#39;range&#39;][&#39;min&#39;], meta[&#39;range&#39;][&#39;max&#39;])
        except KeyError:
          warn(f&#39;메타 정보 파일 ({meta_path.name})에 영상의 밝기 정보가 없습니다. &#39;
               f&#39;영상의 밝기 범위를 변경하지 않습니다.&#39;)
        else:
          image = rescale_intensity(image=image, out_range=img_range)

    return image, meta

  @classmethod
  def save(cls, path: StrPath, array: np.ndarray, check_contrast=False):
    &#34;&#34;&#34;
    주어진 path의 확장자에 따라 영상 파일 저장

    Parameters
    ----------
    path : Union[str, Path]
        저장 경로. `.npy`, `.csv` 및 `.png` 등 영상 확장자 지정 가능
        (`skimage.io.imsave` 참조).
    array : np.ndarray
        저장할 영상
    check_contrast : bool, optional
        `True`인 경우, 영상 파일 확장자 저장 시 영상의 대비가 너무 낮으면 경고.
    &#34;&#34;&#34;
    path = Path(path).resolve()
    if path.suffix == cls.NPY_EXT:
      np.save(file=path.as_posix(), arr=array)
    elif path.suffix == cls.CSV_EXT:
      np.savetxt(fname=path.as_posix(), X=array, delimiter=cls.DELIMITER)
    else:
      imsave(fname=path.as_posix(), arr=array, check_contrast=check_contrast)

  @staticmethod
  def _scale_and_save(array: np.ndarray, path: Path, exts: list, dtype=&#39;uint8&#39;):
    if not exts:
      return
    if dtype not in (&#39;uint8&#39;, &#39;uint16&#39;):
      raise ValueError

    if dtype == &#39;uint8&#39;:
      image = uint8_image(array)
      for ext in exts:
        imsave(fname=path.with_suffix(ext).as_posix(),
               arr=image,
               check_contrast=False)
    else:
      image = uint16_image(array)
      pil_image = PIL.Image.fromarray(image)

      for ext in exts:
        pil_image.save(fp=path.with_suffix(ext))

  @staticmethod
  def _save_image(array: np.ndarray, path: Path, exts: list):
    for ext in exts:
      imsave(fname=path.with_suffix(ext).as_posix(), arr=array)

  @classmethod
  def save_with_meta(cls,
                     path: StrPath,
                     array: np.ndarray,
                     exts: list,
                     meta: Optional[dict] = None,
                     dtype: Optional[str] = None):
    &#34;&#34;&#34;
    주어진 path와 각 확장자 (`exts`)에 따라 영상 파일 저장.
    조건에 따라 주어진 메타 정보를 함께 저장하며, 영상 확장자 (`.png` 등) 파일은
    영상 파일 형식에 맞게 픽셀 값의 범위를 조정함.

    Parameters
    ----------
    path : Union[str, Path]
        저장 경로 (확장자는 `exts`에 따라 변경함).
    array : np.ndarray
        저장할 영상.
    exts : list
        저장할 확장자 목록.
    meta : Optional[dict], optional
        영상의 메타데이터 (Exif 정보 등). `None`이 아니면 `{file name}_meta.yaml`
        파일에 메타 정보 저장.
    dtype : Optional[str], optional
        None이면 입력한 array를 그대로 영상 확장자로 저장. &#39;uint8&#39; 혹은 &#39;uint16&#39;인
        경우, 해당 dtype의 범위로 정규화하고 저장.
    &#34;&#34;&#34;
    path = Path(path)

    # npy 저장
    if cls.NPY_EXT in exts:
      np.save(file=path.with_suffix(cls.NPY_EXT).as_posix(), arr=array)
      exts.remove(cls.NPY_EXT)

    # csv 저장
    if cls.CSV_EXT in exts:
      np.savetxt(fname=path.with_suffix(cls.CSV_EXT).as_posix(),
                 X=array,
                 delimiter=cls.DELIMITER)
      exts.remove(cls.CSV_EXT)

    # 이미지 파일 저장
    if dtype is None:
      cls._save_image(array=array, path=path, exts=exts)
    else:
      cls._scale_and_save(array=array, path=path, exts=exts, dtype=dtype)

    # 메타 데이터 저장
    if meta is not None:
      meta[&#39;range&#39;] = {
          &#39;min&#39;: np.around(np.nanmin(array).item(), 4).item(),
          &#39;max&#39;: np.around(np.nanmax(array).item(), 4).item()
      }
      meta_path = cls.meta_path(path)
      with open(meta_path, &#39;w&#39;, encoding=cls.ENCODING) as f:
        yaml.safe_dump(meta, f, indent=4, sort_keys=False)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="src.misc.imageio.ImageIO.CSV_EXT"><code class="name">var <span class="ident">CSV_EXT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.misc.imageio.ImageIO.DELIMITER"><code class="name">var <span class="ident">DELIMITER</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.misc.imageio.ImageIO.ENCODING"><code class="name">var <span class="ident">ENCODING</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.misc.imageio.ImageIO.META_EXT"><code class="name">var <span class="ident">META_EXT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.misc.imageio.ImageIO.META_SUFFIX"><code class="name">var <span class="ident">META_SUFFIX</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.misc.imageio.ImageIO.NPY_EXT"><code class="name">var <span class="ident">NPY_EXT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.misc.imageio.ImageIO.XLSX_EXT"><code class="name">var <span class="ident">XLSX_EXT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="src.misc.imageio.ImageIO.meta_path"><code class="name flex">
<span>def <span class="ident">meta_path</span></span>(<span>path: pathlib.Path) ‑> pathlib.Path</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def meta_path(cls, path: Path) -&gt; Path:
  return path.with_name(f&#39;{path.stem}{cls.META_SUFFIX}{cls.META_EXT}&#39;)</code></pre>
</details>
</dd>
<dt id="src.misc.imageio.ImageIO.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>path: Union[str, os.PathLike]) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>주어진 path의 확장자에 따라 영상 파일 해석</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>Union[str, Path]</code></dt>
<dd>대상 파일 경로. <code>.npy</code>, <code>.csv</code>, <code>.xlsx</code> 및 <code>.png</code> 등 영상 확장자 지정 가능
(<code>skimage.io.imread</code> 참조).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>FileNotFoundError</code></dt>
<dd>대상 파일이 존재하지 않을 때</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def read(cls, path: StrPath) -&gt; np.ndarray:
  &#34;&#34;&#34;
  주어진 path의 확장자에 따라 영상 파일 해석

  Parameters
  ----------
  path : Union[str, Path]
      대상 파일 경로. `.npy`, `.csv`, `.xlsx` 및 `.png` 등 영상 확장자 지정 가능
      (`skimage.io.imread` 참조).

  Returns
  -------
  np.ndarray

  Raises
  ------
  FileNotFoundError
      대상 파일이 존재하지 않을 때
  &#34;&#34;&#34;
  path = Path(path).resolve()
  if not path.exists():
    raise FileNotFoundError(path)

  if path.suffix == cls.NPY_EXT:
    image = np.load(file=path.as_posix())
  elif path.suffix == cls.CSV_EXT:
    image = np.loadtxt(fname=path.as_posix(), delimiter=cls.DELIMITER)
  elif path.suffix == cls.XLSX_EXT:
    image = pd.read_excel(path.as_posix())
    image = np.array(image)
  else:
    image = imread(fname=path.as_posix())

  return image</code></pre>
</details>
</dd>
<dt id="src.misc.imageio.ImageIO.read_with_meta"><code class="name flex">
<span>def <span class="ident">read_with_meta</span></span>(<span>path: Union[str, os.PathLike], scale=False) ‑> Tuple[numpy.ndarray, Union[dict, NoneType]]</span>
</code></dt>
<dd>
<div class="desc"><p>주어진 path의 확장자에 따라 영상 파일 및 메타 정보 해석.
조건에 따라 영상의 픽셀 값을 메타 정보에 기록된 원 범위로 scale함.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>Union[str, Path]</code></dt>
<dd>대상 파일 경로</dd>
<dt><strong><code>scale</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd><code>True</code>이며 대상 파일이 영상 확장자 (<code>.png</code> 등)인 경우,
<code>save_with_meta</code> 함수로 저장된 메타 정보 파일로부터 읽은
원본 범위로 픽셀 값을 scale함.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>image</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>meta_data</code></strong> :&ensp;<code>Optional[dict]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def read_with_meta(cls,
                   path: StrPath,
                   scale=False) -&gt; Tuple[np.ndarray, Optional[dict]]:
  &#34;&#34;&#34;
  주어진 path의 확장자에 따라 영상 파일 및 메타 정보 해석.
  조건에 따라 영상의 픽셀 값을 메타 정보에 기록된 원 범위로 scale함.

  Parameters
  ----------
  path : Union[str, Path]
      대상 파일 경로
  scale : bool, optional
      `True`이며 대상 파일이 영상 확장자 (`.png` 등)인 경우,
      `save_with_meta` 함수로 저장된 메타 정보 파일로부터 읽은
      원본 범위로 픽셀 값을 scale함.

  Returns
  -------
  image : np.ndarray
  meta_data : Optional[dict]
  &#34;&#34;&#34;
  path = Path(path).resolve()
  image = cls.read(path)

  meta_path = cls.meta_path(path)
  if meta_path.exists():
    with open(meta_path, &#39;r&#39;, encoding=cls.ENCODING) as f:
      meta = yaml.safe_load(f)
  else:
    meta = None

  if scale and path.suffix not in (&#39;.csv&#39;, &#39;.npy&#39;):
    if meta is None:
      warn(f&#39;메타 정보 파일 ({meta_path.name})이 존재하지 않습니다. &#39;
           f&#39;영상의 밝기 범위를 변경하지 않습니다.&#39;)
    else:
      try:
        img_range = (meta[&#39;range&#39;][&#39;min&#39;], meta[&#39;range&#39;][&#39;max&#39;])
      except KeyError:
        warn(f&#39;메타 정보 파일 ({meta_path.name})에 영상의 밝기 정보가 없습니다. &#39;
             f&#39;영상의 밝기 범위를 변경하지 않습니다.&#39;)
      else:
        image = rescale_intensity(image=image, out_range=img_range)

  return image, meta</code></pre>
</details>
</dd>
<dt id="src.misc.imageio.ImageIO.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>path: Union[str, os.PathLike], array: numpy.ndarray, check_contrast=False)</span>
</code></dt>
<dd>
<div class="desc"><p>주어진 path의 확장자에 따라 영상 파일 저장</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>Union[str, Path]</code></dt>
<dd>저장 경로. <code>.npy</code>, <code>.csv</code> 및 <code>.png</code> 등 영상 확장자 지정 가능
(<code>skimage.io.imsave</code> 참조).</dd>
<dt><strong><code>array</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>저장할 영상</dd>
<dt><strong><code>check_contrast</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd><code>True</code>인 경우, 영상 파일 확장자 저장 시 영상의 대비가 너무 낮으면 경고.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def save(cls, path: StrPath, array: np.ndarray, check_contrast=False):
  &#34;&#34;&#34;
  주어진 path의 확장자에 따라 영상 파일 저장

  Parameters
  ----------
  path : Union[str, Path]
      저장 경로. `.npy`, `.csv` 및 `.png` 등 영상 확장자 지정 가능
      (`skimage.io.imsave` 참조).
  array : np.ndarray
      저장할 영상
  check_contrast : bool, optional
      `True`인 경우, 영상 파일 확장자 저장 시 영상의 대비가 너무 낮으면 경고.
  &#34;&#34;&#34;
  path = Path(path).resolve()
  if path.suffix == cls.NPY_EXT:
    np.save(file=path.as_posix(), arr=array)
  elif path.suffix == cls.CSV_EXT:
    np.savetxt(fname=path.as_posix(), X=array, delimiter=cls.DELIMITER)
  else:
    imsave(fname=path.as_posix(), arr=array, check_contrast=check_contrast)</code></pre>
</details>
</dd>
<dt id="src.misc.imageio.ImageIO.save_with_meta"><code class="name flex">
<span>def <span class="ident">save_with_meta</span></span>(<span>path: Union[str, os.PathLike], array: numpy.ndarray, exts: list, meta: Union[dict, NoneType] = None, dtype: Union[str, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>주어진 path와 각 확장자 (<code>exts</code>)에 따라 영상 파일 저장.
조건에 따라 주어진 메타 정보를 함께 저장하며, 영상 확장자 (<code>.png</code> 등) 파일은
영상 파일 형식에 맞게 픽셀 값의 범위를 조정함.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>Union[str, Path]</code></dt>
<dd>저장 경로 (확장자는 <code>exts</code>에 따라 변경함).</dd>
<dt><strong><code>array</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>저장할 영상.</dd>
<dt><strong><code>exts</code></strong> :&ensp;<code>list</code></dt>
<dd>저장할 확장자 목록.</dd>
<dt><strong><code>meta</code></strong> :&ensp;<code>Optional[dict]</code>, optional</dt>
<dd>영상의 메타데이터 (Exif 정보 등). <code>None</code>이 아니면 <code>{file name}_meta.yaml</code>
파일에 메타 정보 저장.</dd>
<dt><strong><code>dtype</code></strong> :&ensp;<code>Optional[str]</code>, optional</dt>
<dd>None이면 입력한 array를 그대로 영상 확장자로 저장. 'uint8' 혹은 'uint16'인
경우, 해당 dtype의 범위로 정규화하고 저장.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def save_with_meta(cls,
                   path: StrPath,
                   array: np.ndarray,
                   exts: list,
                   meta: Optional[dict] = None,
                   dtype: Optional[str] = None):
  &#34;&#34;&#34;
  주어진 path와 각 확장자 (`exts`)에 따라 영상 파일 저장.
  조건에 따라 주어진 메타 정보를 함께 저장하며, 영상 확장자 (`.png` 등) 파일은
  영상 파일 형식에 맞게 픽셀 값의 범위를 조정함.

  Parameters
  ----------
  path : Union[str, Path]
      저장 경로 (확장자는 `exts`에 따라 변경함).
  array : np.ndarray
      저장할 영상.
  exts : list
      저장할 확장자 목록.
  meta : Optional[dict], optional
      영상의 메타데이터 (Exif 정보 등). `None`이 아니면 `{file name}_meta.yaml`
      파일에 메타 정보 저장.
  dtype : Optional[str], optional
      None이면 입력한 array를 그대로 영상 확장자로 저장. &#39;uint8&#39; 혹은 &#39;uint16&#39;인
      경우, 해당 dtype의 범위로 정규화하고 저장.
  &#34;&#34;&#34;
  path = Path(path)

  # npy 저장
  if cls.NPY_EXT in exts:
    np.save(file=path.with_suffix(cls.NPY_EXT).as_posix(), arr=array)
    exts.remove(cls.NPY_EXT)

  # csv 저장
  if cls.CSV_EXT in exts:
    np.savetxt(fname=path.with_suffix(cls.CSV_EXT).as_posix(),
               X=array,
               delimiter=cls.DELIMITER)
    exts.remove(cls.CSV_EXT)

  # 이미지 파일 저장
  if dtype is None:
    cls._save_image(array=array, path=path, exts=exts)
  else:
    cls._scale_and_save(array=array, path=path, exts=exts, dtype=dtype)

  # 메타 데이터 저장
  if meta is not None:
    meta[&#39;range&#39;] = {
        &#39;min&#39;: np.around(np.nanmin(array).item(), 4).item(),
        &#39;max&#39;: np.around(np.nanmax(array).item(), 4).item()
    }
    meta_path = cls.meta_path(path)
    with open(meta_path, &#39;w&#39;, encoding=cls.ENCODING) as f:
      yaml.safe_dump(meta, f, indent=4, sort_keys=False)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="src.misc" href="index.html">src.misc</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="src.misc.imageio.ImageIO" href="#src.misc.imageio.ImageIO">ImageIO</a></code></h4>
<ul class="two-column">
<li><code><a title="src.misc.imageio.ImageIO.CSV_EXT" href="#src.misc.imageio.ImageIO.CSV_EXT">CSV_EXT</a></code></li>
<li><code><a title="src.misc.imageio.ImageIO.DELIMITER" href="#src.misc.imageio.ImageIO.DELIMITER">DELIMITER</a></code></li>
<li><code><a title="src.misc.imageio.ImageIO.ENCODING" href="#src.misc.imageio.ImageIO.ENCODING">ENCODING</a></code></li>
<li><code><a title="src.misc.imageio.ImageIO.META_EXT" href="#src.misc.imageio.ImageIO.META_EXT">META_EXT</a></code></li>
<li><code><a title="src.misc.imageio.ImageIO.META_SUFFIX" href="#src.misc.imageio.ImageIO.META_SUFFIX">META_SUFFIX</a></code></li>
<li><code><a title="src.misc.imageio.ImageIO.NPY_EXT" href="#src.misc.imageio.ImageIO.NPY_EXT">NPY_EXT</a></code></li>
<li><code><a title="src.misc.imageio.ImageIO.XLSX_EXT" href="#src.misc.imageio.ImageIO.XLSX_EXT">XLSX_EXT</a></code></li>
<li><code><a title="src.misc.imageio.ImageIO.meta_path" href="#src.misc.imageio.ImageIO.meta_path">meta_path</a></code></li>
<li><code><a title="src.misc.imageio.ImageIO.read" href="#src.misc.imageio.ImageIO.read">read</a></code></li>
<li><code><a title="src.misc.imageio.ImageIO.read_with_meta" href="#src.misc.imageio.ImageIO.read_with_meta">read_with_meta</a></code></li>
<li><code><a title="src.misc.imageio.ImageIO.save" href="#src.misc.imageio.ImageIO.save">save</a></code></li>
<li><code><a title="src.misc.imageio.ImageIO.save_with_meta" href="#src.misc.imageio.ImageIO.save_with_meta">save_with_meta</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>