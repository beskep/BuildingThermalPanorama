<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>src.misc.tools API documentation</title>
<meta name="description" content="기타 영상 처리 함수들" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>src.misc.tools</code></h1>
</header>
<section id="section-intro">
<p>기타 영상 처리 함수들</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;기타 영상 처리 함수들&#34;&#34;&#34;

import dataclasses as dc
from typing import List, Optional, Tuple, Union

import cv2 as cv
import matplotlib.pyplot as plt
import numpy as np
from skimage.color import rgb2gray, rgba2rgb
from skimage.exposure import equalize_hist, rescale_intensity
from skimage.transform import resize
from skimage.util import compare_images


def normalize_image(image: np.ndarray) -&gt; np.ndarray:
  &#34;&#34;&#34;
  영상의 pixel 값을 [0.0, 1.0] 범위로 정규화

  Parameters
  ----------
  image : np.ndarray
      대상 영상

  Returns
  -------
  np.ndarray
  &#34;&#34;&#34;
  return rescale_intensity(image=image, out_range=(0.0, 1.0))


def uint8_image(image: np.ndarray) -&gt; np.ndarray:
  return rescale_intensity(image, out_range=&#39;uint8&#39;)


def uint16_image(image: np.ndarray) -&gt; np.ndarray:
  return rescale_intensity(image, out_range=&#39;uint16&#39;)


def normalize_rgb_image_hist(image: np.ndarray) -&gt; np.ndarray:
  &#34;&#34;&#34;
  밝기 정규화를 통해 컬러 영상의 명암비 개선

  Parameters
  ----------
  image : np.ndarray
      RGB uint8 영상

  Returns
  -------
  np.ndarray
  &#34;&#34;&#34;
  image_yuv = cv.cvtColor(image, cv.COLOR_RGB2YUV)
  image_yuv[:, :, 0] = cv.normalize(image_yuv[:, :, 0],
                                    dst=None,
                                    alpha=0,
                                    beta=255,
                                    norm_type=cv.NORM_MINMAX)
  equalized = cv.cvtColor(image_yuv, cv.COLOR_YUV2RGB)

  return equalized


def erode(image: np.ndarray, iterations=1) -&gt; np.ndarray:
  kernel = cv.getStructuringElement(cv.MORPH_RECT, (3, 3))
  eroded = cv.erode(image, kernel, iterations=iterations)

  return eroded


def _mask_range(mask, axis):
  mask_ = np.any(mask, axis=axis)
  c1 = np.argmax(mask_)
  c2 = len(mask_) - np.argmax(mask_[::-1])

  return int(c1), int(c2)


def mask_bbox(mask: np.ndarray,
              morphology_open=True) -&gt; Tuple[int, int, int, int]:
  &#34;&#34;&#34;
  마스크 영상 중 True인 영역의 bounding box 좌표를 찾음

  참조:
  https://stackoverflow.com/questions/39206986/numpy-get-rectangle-area-just-the-size-of-mask/48346079

  Parameters
  ----------
  mask : np.ndarray
      2차원 마스크. 대상 영역은 True, 대상 외 영역은 False.
  morphology_open : bool, optional
      Opening (morphological operation)을 통한 노이즈 제거 여부

  Returns
  -------
  Tuple[int]
      (x_min, x_max, y_min, y_max)

  Raises
  ------
  ValueError
      if mask.ndim != 2
  &#34;&#34;&#34;
  if mask.ndim != 2:
    raise ValueError

  if morphology_open:
    kernel = np.ones(shape=(3, 3), dtype=np.uint8)
    mask_ = cv.morphologyEx(src=mask.astype(np.uint8),
                            op=cv.MORPH_OPEN,
                            kernel=kernel)
  else:
    mask_ = mask

  xx = _mask_range(mask=mask_, axis=0)
  yy = _mask_range(mask=mask_, axis=1)

  return xx + yy


@dc.dataclass
class CropRange:
  x_min: int
  x_max: int
  y_min: int
  y_max: int
  image_shape: tuple

  cropped: bool = dc.field(init=False)

  def __post_init__(self):
    self.cropped = ((self.x_min &gt; 0 or self.x_max &lt; self.image_shape[1]) and
                    (self.y_min &gt; 0 or self.y_min &lt; self.image_shape[0]))

  def as_tuple(self):
    return (self.x_min, self.x_max, self.y_min, self.y_max)

  def crop(self, image: np.ndarray):
    if image.shape[:2] != self.image_shape[:2]:
      raise ValueError(&#39;Input shape ({}) != {}&#39;.format(image.shape[:2],
                                                       self.image_shape[:2]))

    return image[self.y_min:self.y_max, self.x_min:self.x_max]


def crop_mask(mask: np.ndarray,
              morphology_open=True) -&gt; Tuple[CropRange, np.ndarray]:
  bbox = mask_bbox(mask=mask.astype(bool), morphology_open=morphology_open)
  cr = CropRange(*bbox, mask.shape[:2])

  if cr.cropped:
    cropped = cr.crop(mask)
  else:
    cropped = mask

  return cr, cropped


def bin_size(image1: np.ndarray,
             image2: Optional[np.ndarray] = None,
             bins=&#39;auto&#39;) -&gt; int:
  &#34;&#34;&#34;
  영상의 histogram, entropy 계산을 위한 적정 bin 개수 추정.
  `numpy.histogram_bin_edges`함수를 이용함.

  Parameters
  ----------
  image1 : np.ndarray
      대상 영상.
  image2 : Optional[np.ndarray]
      대상 영상. 미입력 시 image1만 고려해서 bins 산정.

      입력 시 image1과 image2의 적정 bins의 평균으로 결정.
  bins : str, optional
      추정 방법. `numpy.histogram_bin_edges` 참조.

  Returns
  -------
  int
      Histogram의 적정 bin 개수
  &#34;&#34;&#34;
  bins_count = np.histogram_bin_edges(image1, bins=bins).size
  if image2 is not None:
    bins_count2 = np.histogram_bin_edges(image2, bins=bins).size
    bins_count = (bins_count + bins_count2) // 2

  return bins_count


def gray_image(image: np.ndarray) -&gt; np.ndarray:
  &#34;&#34;&#34;
  RGB, RGBA 영상을 gray scale로 변환.
  2채널 흑백 영상은 원본 그대로 반환.

  Parameters
  ----------
  image : np.ndarray

  Returns
  -------
  np.ndarray

  Raises
  ------
  ValueError
      if image.ndim not in {2, 3}
  &#34;&#34;&#34;
  if image.ndim == 3:
    if image.shape[2] == 4:
      image = rgba2rgb(image)

    return rgb2gray(image)

  if image.ndim != 2:
    raise ValueError

  return image


def _check_and_prep(image1: np.ndarray, image2: np.ndarray, normalize: bool,
                    eq_hist: bool) -&gt; Tuple[np.ndarray, np.ndarray]:
  image1 = gray_image(image1)
  image2 = gray_image(image2)

  if image1.shape != image2.shape:
    raise ValueError(&#39;image1.shape != image2.shape&#39;)
  if image1.ndim != 2:
    raise ValueError(&#39;image1.ndim != 2&#39;)
  if image2.ndim != 2:
    raise ValueError(&#39;image2.ndim != 2&#39;)

  if normalize:
    image1 = normalize_image(image1)
    image2 = normalize_image(image2)

  if eq_hist:
    image1 = equalize_hist(normalize_image(image1))
    image2 = equalize_hist(normalize_image(image2))

  return image1, image2


def prep_compare_images(
    image1: np.ndarray,
    image2: np.ndarray,
    norm=False,
    eq_hist=True,
    method: Union[str, List[str]] = &#39;checkerboard&#39;,
    n_tiles=(8, 8)
) -&gt; Union[np.ndarray, List[np.ndarray]]:
  &#34;&#34;&#34;
  두 영상의 전처리 및 비교 영상 생성.
  두 영상 모두 2차원 (gray image)이며 해상도 (ndarray.shape)이 동일해야 함.

  Parameters
  ----------
  image1 : np.ndarray
      대상 영상 1
  image2 : np.ndarray
      대상 영상 2
  norm : bool, optional
      `True`이면 픽셀 밝기 단위를 0에서 1까지 normalize
  eq_hist : bool, optional
      명암 개선을 위해 Histogram Equalization 적용 여부
  method : Union[str, List[str]], optional
      `skimage.exposure.compare_images` 옵션.
      list로 주어지면 각 옵션을 적용한 비교 영상의 list 반환.
  n_tiles : tuple, optional
      Checkerboard 타일 개수

  Returns
  -------
  Union[np.ndarray, List[np.ndarray]]

  Raises
  ------
  ValueError
      두 영상의 해상도 (shape)이 다르거나 2차원이 아닌 경우
  &#34;&#34;&#34;
  img1, img2 = _check_and_prep(image1=image1,
                               image2=image2,
                               normalize=norm,
                               eq_hist=eq_hist)
  if isinstance(method, str):
    res = compare_images(img1, img2, method=method, n_tiles=n_tiles)
  else:
    res = []
    for m in method:
      image = compare_images(img1, img2, method=m, n_tiles=n_tiles)
      res.append(image)

  return res


def prep_compare_fig(images: Tuple[np.ndarray, np.ndarray],
                     titles=(&#39;Image 1&#39;, &#39;Image 2&#39;),
                     norm=False,
                     eq_hist=True,
                     n_tiles=(8, 8)):
  &#34;&#34;&#34;
  두 영상의 전처리 및 비교 영상 생성.
  두 영상 모두 2차원 (gray image)이며 해상도 (ndarray.shape)이 동일해야 함.

  Parameters
  ----------
  images : Tuple[np.ndarray, np.ndarray]
      대상 영상
  titles : tuple
      figure에 표시할 각 영상 제목
  norm : bool, optional
      `True`이면 픽셀 밝기 단위를 0에서 1까지 normalize
  eq_hist : bool, optional
      명암 개선을 위해 Histogram Equalization 적용 여부
  n_tiles : tuple, optional
      Checkerboard 타일 개수

  Returns
  -------
  tuple:
      plt.Figure

      np.ndarray of plt.Axes

  Raises
  ------
  ValueError
      두 영상의 해상도 (shape)이 다르거나 2차원이 아닌 경우
  &#34;&#34;&#34;
  img1, img2 = _check_and_prep(image1=images[0],
                               image2=images[1],
                               normalize=norm,
                               eq_hist=eq_hist)

  fig, axes = plt.subplots(2, 2, figsize=(16, 9))
  cmap = &#39;gray&#39;

  axes[0, 0].imshow(images[0], cmap=cmap)
  axes[0, 0].set_title(titles[0])

  axes[0, 1].imshow(images[1], cmap=cmap)
  axes[0, 1].set_title(titles[1])

  cb = compare_images(img1, img2, method=&#39;checkerboard&#39;, n_tiles=n_tiles)

  axes[1, 0].imshow(cb, cmap=cmap)
  axes[1, 0].set_title(&#39;Compare (checkerboard)&#39;)

  diff = compare_images(img1, img2, method=&#39;diff&#39;)
  axes[1, 1].imshow(diff, cmap=cmap)
  axes[1, 1].set_title(&#39;Compare (difference)&#39;)

  for ax in axes.ravel():
    ax.set_axis_off()

  fig.tight_layout()

  return fig, axes


def limit_image_size(image: np.ndarray, limit: int) -&gt; np.ndarray:
  max_shape = np.max(image.shape[:2]).astype(float)
  if max_shape &lt;= limit:
    return image

  dtype = image.dtype

  ratio = limit / max_shape
  target_shape = (int(image.shape[0] * ratio), int(image.shape[1] * ratio))

  resized = resize(image=image.astype(np.float32),
                   output_shape=target_shape,
                   preserve_range=True,
                   anti_aliasing=True)

  return resized.astype(dtype)


class SegMask:
  _scale = 60

  @classmethod
  def index_to_vis(cls, array: np.ndarray):
    return array.astype(np.uint8) * cls._scale

  @classmethod
  def vis_to_index(cls, array: np.ndarray):
    return (array / cls._scale).astype(np.uint8)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="src.misc.tools.bin_size"><code class="name flex">
<span>def <span class="ident">bin_size</span></span>(<span>image1: numpy.ndarray, image2: Union[numpy.ndarray, NoneType] = None, bins='auto') ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>영상의 histogram, entropy 계산을 위한 적정 bin 개수 추정.
<code>numpy.histogram_bin_edges</code>함수를 이용함.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>image1</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>대상 영상.</dd>
<dt><strong><code>image2</code></strong> :&ensp;<code>Optional[np.ndarray]</code></dt>
<dd>
<p>대상 영상. 미입력 시 image1만 고려해서 bins 산정.</p>
<p>입력 시 image1과 image2의 적정 bins의 평균으로 결정.</p>
</dd>
<dt><strong><code>bins</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>추정 방법. <code>numpy.histogram_bin_edges</code> 참조.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>Histogram의 적정 bin 개수</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bin_size(image1: np.ndarray,
             image2: Optional[np.ndarray] = None,
             bins=&#39;auto&#39;) -&gt; int:
  &#34;&#34;&#34;
  영상의 histogram, entropy 계산을 위한 적정 bin 개수 추정.
  `numpy.histogram_bin_edges`함수를 이용함.

  Parameters
  ----------
  image1 : np.ndarray
      대상 영상.
  image2 : Optional[np.ndarray]
      대상 영상. 미입력 시 image1만 고려해서 bins 산정.

      입력 시 image1과 image2의 적정 bins의 평균으로 결정.
  bins : str, optional
      추정 방법. `numpy.histogram_bin_edges` 참조.

  Returns
  -------
  int
      Histogram의 적정 bin 개수
  &#34;&#34;&#34;
  bins_count = np.histogram_bin_edges(image1, bins=bins).size
  if image2 is not None:
    bins_count2 = np.histogram_bin_edges(image2, bins=bins).size
    bins_count = (bins_count + bins_count2) // 2

  return bins_count</code></pre>
</details>
</dd>
<dt id="src.misc.tools.crop_mask"><code class="name flex">
<span>def <span class="ident">crop_mask</span></span>(<span>mask: numpy.ndarray, morphology_open=True) ‑> Tuple[<a title="src.misc.tools.CropRange" href="#src.misc.tools.CropRange">CropRange</a>, numpy.ndarray]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def crop_mask(mask: np.ndarray,
              morphology_open=True) -&gt; Tuple[CropRange, np.ndarray]:
  bbox = mask_bbox(mask=mask.astype(bool), morphology_open=morphology_open)
  cr = CropRange(*bbox, mask.shape[:2])

  if cr.cropped:
    cropped = cr.crop(mask)
  else:
    cropped = mask

  return cr, cropped</code></pre>
</details>
</dd>
<dt id="src.misc.tools.erode"><code class="name flex">
<span>def <span class="ident">erode</span></span>(<span>image: numpy.ndarray, iterations=1) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def erode(image: np.ndarray, iterations=1) -&gt; np.ndarray:
  kernel = cv.getStructuringElement(cv.MORPH_RECT, (3, 3))
  eroded = cv.erode(image, kernel, iterations=iterations)

  return eroded</code></pre>
</details>
</dd>
<dt id="src.misc.tools.gray_image"><code class="name flex">
<span>def <span class="ident">gray_image</span></span>(<span>image: numpy.ndarray) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>RGB, RGBA 영상을 gray scale로 변환.
2채널 흑백 영상은 원본 그대로 반환.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>image</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>if image.ndim not in {2, 3}</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gray_image(image: np.ndarray) -&gt; np.ndarray:
  &#34;&#34;&#34;
  RGB, RGBA 영상을 gray scale로 변환.
  2채널 흑백 영상은 원본 그대로 반환.

  Parameters
  ----------
  image : np.ndarray

  Returns
  -------
  np.ndarray

  Raises
  ------
  ValueError
      if image.ndim not in {2, 3}
  &#34;&#34;&#34;
  if image.ndim == 3:
    if image.shape[2] == 4:
      image = rgba2rgb(image)

    return rgb2gray(image)

  if image.ndim != 2:
    raise ValueError

  return image</code></pre>
</details>
</dd>
<dt id="src.misc.tools.limit_image_size"><code class="name flex">
<span>def <span class="ident">limit_image_size</span></span>(<span>image: numpy.ndarray, limit: int) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def limit_image_size(image: np.ndarray, limit: int) -&gt; np.ndarray:
  max_shape = np.max(image.shape[:2]).astype(float)
  if max_shape &lt;= limit:
    return image

  dtype = image.dtype

  ratio = limit / max_shape
  target_shape = (int(image.shape[0] * ratio), int(image.shape[1] * ratio))

  resized = resize(image=image.astype(np.float32),
                   output_shape=target_shape,
                   preserve_range=True,
                   anti_aliasing=True)

  return resized.astype(dtype)</code></pre>
</details>
</dd>
<dt id="src.misc.tools.mask_bbox"><code class="name flex">
<span>def <span class="ident">mask_bbox</span></span>(<span>mask: numpy.ndarray, morphology_open=True) ‑> Tuple[int, int, int, int]</span>
</code></dt>
<dd>
<div class="desc"><p>마스크 영상 중 True인 영역의 bounding box 좌표를 찾음</p>
<p>참조:
<a href="https://stackoverflow.com/questions/39206986/numpy-get-rectangle-area-just-the-size-of-mask/48346079">https://stackoverflow.com/questions/39206986/numpy-get-rectangle-area-just-the-size-of-mask/48346079</a></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>mask</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>2차원 마스크. 대상 영역은 True, 대상 외 영역은 False.</dd>
<dt><strong><code>morphology_open</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Opening (morphological operation)을 통한 노이즈 제거 여부</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tuple[int]</code></dt>
<dd>(x_min, x_max, y_min, y_max)</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>if mask.ndim != 2</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mask_bbox(mask: np.ndarray,
              morphology_open=True) -&gt; Tuple[int, int, int, int]:
  &#34;&#34;&#34;
  마스크 영상 중 True인 영역의 bounding box 좌표를 찾음

  참조:
  https://stackoverflow.com/questions/39206986/numpy-get-rectangle-area-just-the-size-of-mask/48346079

  Parameters
  ----------
  mask : np.ndarray
      2차원 마스크. 대상 영역은 True, 대상 외 영역은 False.
  morphology_open : bool, optional
      Opening (morphological operation)을 통한 노이즈 제거 여부

  Returns
  -------
  Tuple[int]
      (x_min, x_max, y_min, y_max)

  Raises
  ------
  ValueError
      if mask.ndim != 2
  &#34;&#34;&#34;
  if mask.ndim != 2:
    raise ValueError

  if morphology_open:
    kernel = np.ones(shape=(3, 3), dtype=np.uint8)
    mask_ = cv.morphologyEx(src=mask.astype(np.uint8),
                            op=cv.MORPH_OPEN,
                            kernel=kernel)
  else:
    mask_ = mask

  xx = _mask_range(mask=mask_, axis=0)
  yy = _mask_range(mask=mask_, axis=1)

  return xx + yy</code></pre>
</details>
</dd>
<dt id="src.misc.tools.normalize_image"><code class="name flex">
<span>def <span class="ident">normalize_image</span></span>(<span>image: numpy.ndarray) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>영상의 pixel 값을 [0.0, 1.0] 범위로 정규화</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>image</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>대상 영상</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normalize_image(image: np.ndarray) -&gt; np.ndarray:
  &#34;&#34;&#34;
  영상의 pixel 값을 [0.0, 1.0] 범위로 정규화

  Parameters
  ----------
  image : np.ndarray
      대상 영상

  Returns
  -------
  np.ndarray
  &#34;&#34;&#34;
  return rescale_intensity(image=image, out_range=(0.0, 1.0))</code></pre>
</details>
</dd>
<dt id="src.misc.tools.normalize_rgb_image_hist"><code class="name flex">
<span>def <span class="ident">normalize_rgb_image_hist</span></span>(<span>image: numpy.ndarray) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>밝기 정규화를 통해 컬러 영상의 명암비 개선</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>image</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>RGB uint8 영상</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normalize_rgb_image_hist(image: np.ndarray) -&gt; np.ndarray:
  &#34;&#34;&#34;
  밝기 정규화를 통해 컬러 영상의 명암비 개선

  Parameters
  ----------
  image : np.ndarray
      RGB uint8 영상

  Returns
  -------
  np.ndarray
  &#34;&#34;&#34;
  image_yuv = cv.cvtColor(image, cv.COLOR_RGB2YUV)
  image_yuv[:, :, 0] = cv.normalize(image_yuv[:, :, 0],
                                    dst=None,
                                    alpha=0,
                                    beta=255,
                                    norm_type=cv.NORM_MINMAX)
  equalized = cv.cvtColor(image_yuv, cv.COLOR_YUV2RGB)

  return equalized</code></pre>
</details>
</dd>
<dt id="src.misc.tools.prep_compare_fig"><code class="name flex">
<span>def <span class="ident">prep_compare_fig</span></span>(<span>images: Tuple[numpy.ndarray, numpy.ndarray], titles=('Image 1', 'Image 2'), norm=False, eq_hist=True, n_tiles=(8, 8))</span>
</code></dt>
<dd>
<div class="desc"><p>두 영상의 전처리 및 비교 영상 생성.
두 영상 모두 2차원 (gray image)이며 해상도 (ndarray.shape)이 동일해야 함.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>images</code></strong> :&ensp;<code>Tuple[np.ndarray, np.ndarray]</code></dt>
<dd>대상 영상</dd>
<dt><strong><code>titles</code></strong> :&ensp;<code>tuple</code></dt>
<dd>figure에 표시할 각 영상 제목</dd>
<dt><strong><code>norm</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd><code>True</code>이면 픽셀 밝기 단위를 0에서 1까지 normalize</dd>
<dt><strong><code>eq_hist</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>명암 개선을 위해 Histogram Equalization 적용 여부</dd>
<dt><strong><code>n_tiles</code></strong> :&ensp;<code>tuple</code>, optional</dt>
<dd>Checkerboard 타일 개수</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple:</code></dt>
<dd>
<p>plt.Figure</p>
<p>np.ndarray of plt.Axes</p>
</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>두 영상의 해상도 (shape)이 다르거나 2차원이 아닌 경우</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prep_compare_fig(images: Tuple[np.ndarray, np.ndarray],
                     titles=(&#39;Image 1&#39;, &#39;Image 2&#39;),
                     norm=False,
                     eq_hist=True,
                     n_tiles=(8, 8)):
  &#34;&#34;&#34;
  두 영상의 전처리 및 비교 영상 생성.
  두 영상 모두 2차원 (gray image)이며 해상도 (ndarray.shape)이 동일해야 함.

  Parameters
  ----------
  images : Tuple[np.ndarray, np.ndarray]
      대상 영상
  titles : tuple
      figure에 표시할 각 영상 제목
  norm : bool, optional
      `True`이면 픽셀 밝기 단위를 0에서 1까지 normalize
  eq_hist : bool, optional
      명암 개선을 위해 Histogram Equalization 적용 여부
  n_tiles : tuple, optional
      Checkerboard 타일 개수

  Returns
  -------
  tuple:
      plt.Figure

      np.ndarray of plt.Axes

  Raises
  ------
  ValueError
      두 영상의 해상도 (shape)이 다르거나 2차원이 아닌 경우
  &#34;&#34;&#34;
  img1, img2 = _check_and_prep(image1=images[0],
                               image2=images[1],
                               normalize=norm,
                               eq_hist=eq_hist)

  fig, axes = plt.subplots(2, 2, figsize=(16, 9))
  cmap = &#39;gray&#39;

  axes[0, 0].imshow(images[0], cmap=cmap)
  axes[0, 0].set_title(titles[0])

  axes[0, 1].imshow(images[1], cmap=cmap)
  axes[0, 1].set_title(titles[1])

  cb = compare_images(img1, img2, method=&#39;checkerboard&#39;, n_tiles=n_tiles)

  axes[1, 0].imshow(cb, cmap=cmap)
  axes[1, 0].set_title(&#39;Compare (checkerboard)&#39;)

  diff = compare_images(img1, img2, method=&#39;diff&#39;)
  axes[1, 1].imshow(diff, cmap=cmap)
  axes[1, 1].set_title(&#39;Compare (difference)&#39;)

  for ax in axes.ravel():
    ax.set_axis_off()

  fig.tight_layout()

  return fig, axes</code></pre>
</details>
</dd>
<dt id="src.misc.tools.prep_compare_images"><code class="name flex">
<span>def <span class="ident">prep_compare_images</span></span>(<span>image1: numpy.ndarray, image2: numpy.ndarray, norm=False, eq_hist=True, method: Union[str, List[str]] = 'checkerboard', n_tiles=(8, 8)) ‑> Union[numpy.ndarray, List[numpy.ndarray]]</span>
</code></dt>
<dd>
<div class="desc"><p>두 영상의 전처리 및 비교 영상 생성.
두 영상 모두 2차원 (gray image)이며 해상도 (ndarray.shape)이 동일해야 함.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>image1</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>대상 영상 1</dd>
<dt><strong><code>image2</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>대상 영상 2</dd>
<dt><strong><code>norm</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd><code>True</code>이면 픽셀 밝기 단위를 0에서 1까지 normalize</dd>
<dt><strong><code>eq_hist</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>명암 개선을 위해 Histogram Equalization 적용 여부</dd>
<dt><strong><code>method</code></strong> :&ensp;<code>Union[str, List[str]]</code>, optional</dt>
<dd><code>skimage.exposure.compare_images</code> 옵션.
list로 주어지면 각 옵션을 적용한 비교 영상의 list 반환.</dd>
<dt><strong><code>n_tiles</code></strong> :&ensp;<code>tuple</code>, optional</dt>
<dd>Checkerboard 타일 개수</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[np.ndarray, List[np.ndarray]]</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>두 영상의 해상도 (shape)이 다르거나 2차원이 아닌 경우</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prep_compare_images(
    image1: np.ndarray,
    image2: np.ndarray,
    norm=False,
    eq_hist=True,
    method: Union[str, List[str]] = &#39;checkerboard&#39;,
    n_tiles=(8, 8)
) -&gt; Union[np.ndarray, List[np.ndarray]]:
  &#34;&#34;&#34;
  두 영상의 전처리 및 비교 영상 생성.
  두 영상 모두 2차원 (gray image)이며 해상도 (ndarray.shape)이 동일해야 함.

  Parameters
  ----------
  image1 : np.ndarray
      대상 영상 1
  image2 : np.ndarray
      대상 영상 2
  norm : bool, optional
      `True`이면 픽셀 밝기 단위를 0에서 1까지 normalize
  eq_hist : bool, optional
      명암 개선을 위해 Histogram Equalization 적용 여부
  method : Union[str, List[str]], optional
      `skimage.exposure.compare_images` 옵션.
      list로 주어지면 각 옵션을 적용한 비교 영상의 list 반환.
  n_tiles : tuple, optional
      Checkerboard 타일 개수

  Returns
  -------
  Union[np.ndarray, List[np.ndarray]]

  Raises
  ------
  ValueError
      두 영상의 해상도 (shape)이 다르거나 2차원이 아닌 경우
  &#34;&#34;&#34;
  img1, img2 = _check_and_prep(image1=image1,
                               image2=image2,
                               normalize=norm,
                               eq_hist=eq_hist)
  if isinstance(method, str):
    res = compare_images(img1, img2, method=method, n_tiles=n_tiles)
  else:
    res = []
    for m in method:
      image = compare_images(img1, img2, method=m, n_tiles=n_tiles)
      res.append(image)

  return res</code></pre>
</details>
</dd>
<dt id="src.misc.tools.uint16_image"><code class="name flex">
<span>def <span class="ident">uint16_image</span></span>(<span>image: numpy.ndarray) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def uint16_image(image: np.ndarray) -&gt; np.ndarray:
  return rescale_intensity(image, out_range=&#39;uint16&#39;)</code></pre>
</details>
</dd>
<dt id="src.misc.tools.uint8_image"><code class="name flex">
<span>def <span class="ident">uint8_image</span></span>(<span>image: numpy.ndarray) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def uint8_image(image: np.ndarray) -&gt; np.ndarray:
  return rescale_intensity(image, out_range=&#39;uint8&#39;)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="src.misc.tools.CropRange"><code class="flex name class">
<span>class <span class="ident">CropRange</span></span>
<span>(</span><span>x_min: int, x_max: int, y_min: int, y_max: int, image_shape: tuple)</span>
</code></dt>
<dd>
<div class="desc"><p>CropRange(x_min: int, x_max: int, y_min: int, y_max: int, image_shape: tuple)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CropRange:
  x_min: int
  x_max: int
  y_min: int
  y_max: int
  image_shape: tuple

  cropped: bool = dc.field(init=False)

  def __post_init__(self):
    self.cropped = ((self.x_min &gt; 0 or self.x_max &lt; self.image_shape[1]) and
                    (self.y_min &gt; 0 or self.y_min &lt; self.image_shape[0]))

  def as_tuple(self):
    return (self.x_min, self.x_max, self.y_min, self.y_max)

  def crop(self, image: np.ndarray):
    if image.shape[:2] != self.image_shape[:2]:
      raise ValueError(&#39;Input shape ({}) != {}&#39;.format(image.shape[:2],
                                                       self.image_shape[:2]))

    return image[self.y_min:self.y_max, self.x_min:self.x_max]</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="src.misc.tools.CropRange.cropped"><code class="name">var <span class="ident">cropped</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.misc.tools.CropRange.image_shape"><code class="name">var <span class="ident">image_shape</span> : tuple</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.misc.tools.CropRange.x_max"><code class="name">var <span class="ident">x_max</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.misc.tools.CropRange.x_min"><code class="name">var <span class="ident">x_min</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.misc.tools.CropRange.y_max"><code class="name">var <span class="ident">y_max</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.misc.tools.CropRange.y_min"><code class="name">var <span class="ident">y_min</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="src.misc.tools.CropRange.as_tuple"><code class="name flex">
<span>def <span class="ident">as_tuple</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def as_tuple(self):
  return (self.x_min, self.x_max, self.y_min, self.y_max)</code></pre>
</details>
</dd>
<dt id="src.misc.tools.CropRange.crop"><code class="name flex">
<span>def <span class="ident">crop</span></span>(<span>self, image: numpy.ndarray)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def crop(self, image: np.ndarray):
  if image.shape[:2] != self.image_shape[:2]:
    raise ValueError(&#39;Input shape ({}) != {}&#39;.format(image.shape[:2],
                                                     self.image_shape[:2]))

  return image[self.y_min:self.y_max, self.x_min:self.x_max]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="src.misc.tools.SegMask"><code class="flex name class">
<span>class <span class="ident">SegMask</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SegMask:
  _scale = 60

  @classmethod
  def index_to_vis(cls, array: np.ndarray):
    return array.astype(np.uint8) * cls._scale

  @classmethod
  def vis_to_index(cls, array: np.ndarray):
    return (array / cls._scale).astype(np.uint8)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="src.misc.tools.SegMask.index_to_vis"><code class="name flex">
<span>def <span class="ident">index_to_vis</span></span>(<span>array: numpy.ndarray)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def index_to_vis(cls, array: np.ndarray):
  return array.astype(np.uint8) * cls._scale</code></pre>
</details>
</dd>
<dt id="src.misc.tools.SegMask.vis_to_index"><code class="name flex">
<span>def <span class="ident">vis_to_index</span></span>(<span>array: numpy.ndarray)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def vis_to_index(cls, array: np.ndarray):
  return (array / cls._scale).astype(np.uint8)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="src.misc" href="index.html">src.misc</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="src.misc.tools.bin_size" href="#src.misc.tools.bin_size">bin_size</a></code></li>
<li><code><a title="src.misc.tools.crop_mask" href="#src.misc.tools.crop_mask">crop_mask</a></code></li>
<li><code><a title="src.misc.tools.erode" href="#src.misc.tools.erode">erode</a></code></li>
<li><code><a title="src.misc.tools.gray_image" href="#src.misc.tools.gray_image">gray_image</a></code></li>
<li><code><a title="src.misc.tools.limit_image_size" href="#src.misc.tools.limit_image_size">limit_image_size</a></code></li>
<li><code><a title="src.misc.tools.mask_bbox" href="#src.misc.tools.mask_bbox">mask_bbox</a></code></li>
<li><code><a title="src.misc.tools.normalize_image" href="#src.misc.tools.normalize_image">normalize_image</a></code></li>
<li><code><a title="src.misc.tools.normalize_rgb_image_hist" href="#src.misc.tools.normalize_rgb_image_hist">normalize_rgb_image_hist</a></code></li>
<li><code><a title="src.misc.tools.prep_compare_fig" href="#src.misc.tools.prep_compare_fig">prep_compare_fig</a></code></li>
<li><code><a title="src.misc.tools.prep_compare_images" href="#src.misc.tools.prep_compare_images">prep_compare_images</a></code></li>
<li><code><a title="src.misc.tools.uint16_image" href="#src.misc.tools.uint16_image">uint16_image</a></code></li>
<li><code><a title="src.misc.tools.uint8_image" href="#src.misc.tools.uint8_image">uint8_image</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="src.misc.tools.CropRange" href="#src.misc.tools.CropRange">CropRange</a></code></h4>
<ul class="two-column">
<li><code><a title="src.misc.tools.CropRange.as_tuple" href="#src.misc.tools.CropRange.as_tuple">as_tuple</a></code></li>
<li><code><a title="src.misc.tools.CropRange.crop" href="#src.misc.tools.CropRange.crop">crop</a></code></li>
<li><code><a title="src.misc.tools.CropRange.cropped" href="#src.misc.tools.CropRange.cropped">cropped</a></code></li>
<li><code><a title="src.misc.tools.CropRange.image_shape" href="#src.misc.tools.CropRange.image_shape">image_shape</a></code></li>
<li><code><a title="src.misc.tools.CropRange.x_max" href="#src.misc.tools.CropRange.x_max">x_max</a></code></li>
<li><code><a title="src.misc.tools.CropRange.x_min" href="#src.misc.tools.CropRange.x_min">x_min</a></code></li>
<li><code><a title="src.misc.tools.CropRange.y_max" href="#src.misc.tools.CropRange.y_max">y_max</a></code></li>
<li><code><a title="src.misc.tools.CropRange.y_min" href="#src.misc.tools.CropRange.y_min">y_min</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="src.misc.tools.SegMask" href="#src.misc.tools.SegMask">SegMask</a></code></h4>
<ul class="">
<li><code><a title="src.misc.tools.SegMask.index_to_vis" href="#src.misc.tools.SegMask.index_to_vis">index_to_vis</a></code></li>
<li><code><a title="src.misc.tools.SegMask.vis_to_index" href="#src.misc.tools.SegMask.vis_to_index">vis_to_index</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>