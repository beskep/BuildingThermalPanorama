<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>src.misc.tools API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>src.misc.tools</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from pathlib import Path
from shutil import copy2
from typing import Optional, Tuple, Union
from warnings import warn

import utils

import cv2 as cv
import numpy as np
import pandas as pd
import PIL.Image
import yaml
from matplotlib.pyplot import get_cmap
from rich.progress import track
from skimage.exposure import equalize_hist, rescale_intensity
from skimage.io import imread, imsave
from skimage.util import compare_images


def normalize_image(image: np.ndarray) -&gt; np.ndarray:
  &#34;&#34;&#34;
  영상의 pixel 값을 [0.0, 1.0] 범위로 정규화

  Parameters
  ----------
  image : np.ndarray
      대상 영상

  Returns
  -------
  np.ndarray
  &#34;&#34;&#34;
  return rescale_intensity(image=image, out_range=(0.0, 1.0))


def uint8_image(image: np.ndarray) -&gt; np.ndarray:
  return rescale_intensity(image, out_range=&#39;uint8&#39;)


def uint16_image(image: np.ndarray) -&gt; np.ndarray:
  return rescale_intensity(image, out_range=&#39;uint16&#39;)


def normalize_rgb_image_hist(image: np.ndarray) -&gt; np.ndarray:
  &#34;&#34;&#34;
  밝기 정규화를 통해 컬러 영상의 명암비 개선

  Parameters
  ----------
  image : np.ndarray
      RGB uint8 영상

  Returns
  -------
  np.ndarray
  &#34;&#34;&#34;
  image_yuv = cv.cvtColor(image, cv.COLOR_RGB2YUV)
  image_yuv[:, :, 0] = cv.normalize(image_yuv[:, :, 0],
                                    dst=None,
                                    alpha=0,
                                    beta=255,
                                    norm_type=cv.NORM_MINMAX)
  equalized = cv.cvtColor(image_yuv, cv.COLOR_YUV2RGB)

  return equalized


def _mask_range(mask, axis):
  mask_ = np.any(mask, axis=axis)
  c1 = np.argmax(mask_)
  c2 = len(mask_) - np.argmax(mask_[::-1])

  return int(c1), int(c2)


def mask_bbox(mask: np.ndarray,
              morphology_open=True) -&gt; Tuple[int, int, int, int]:
  &#34;&#34;&#34;
  마스크 영상 중 True인 영역의 bounding box 좌표를 찾음

  참조: https://stackoverflow.com/questions/39206986/numpy-get-rectangle-area-just-the-size-of-mask/48346079

  Parameters
  ----------
  mask : np.ndarray
      2차원 마스크. 대상 영역은 True, 대상 외 영역은 False.
  morphology_open : bool, optional
      Opening (morphological operation)을 통한 노이즈 제거 여부

  Returns
  -------
  Tuple[int, int, int, int]
      (x_min, x_max, y_min, y_max)

  Raises
  ------
  ValueError
      입력한 마스크가 2차원이 아닌 경우
  &#34;&#34;&#34;
  if mask.ndim != 2:
    raise ValueError

  if morphology_open:
    kernel = np.ones(shape=(3, 3), dtype=&#39;uint8&#39;)
    mask_ = cv.morphologyEx(src=mask, op=cv.MORPH_OPEN, kernel=kernel)
  else:
    mask_ = mask

  xx = _mask_range(mask=mask_, axis=0)
  yy = _mask_range(mask=mask_, axis=1)

  return xx + yy


def bin_size(image1: np.ndarray,
             image2: Optional[np.ndarray] = None,
             bins=&#39;auto&#39;) -&gt; int:
  &#34;&#34;&#34;
  영상의 histogram, entropy 계산을 위한 적정 bin 개수 추정.
  `numpy.histogram_bin_edges`함수를 이용함.

  Parameters
  ----------
  image1 : np.ndarray
      대상 영상.
  image2 : Optional[np.ndarray]
      대상 영상. 미입력 시 image1만 고려해서 bins 산정.

      입력 시 image1과 image2의 적정 bins의 평균으로 결정.
  bins : str, optional
      추정 방법. `numpy.histogram_bin_edges` 참조.

  Returns
  -------
  int
      Histogram의 적정 bin 개수
  &#34;&#34;&#34;
  bins_count = np.histogram_bin_edges(image1, bins=bins).size
  if image2 is not None:
    bins_count2 = np.histogram_bin_edges(image2, bins=bins).size
    bins_count = (bins_count + bins_count2) // 2

  return bins_count


def prep_compare_images(image1: np.ndarray,
                        image2: np.ndarray,
                        eq_hist=True,
                        method=&#39;checkerboard&#39;,
                        **kwargs) -&gt; np.ndarray:
  &#34;&#34;&#34;
  두 영상의 전처리 및 비교 영상 생성.
  두 영상 모두 2차원 (gray image)이며 해상도 (ndarray.shape)이 동일해야 함.

  Parameters
  ----------
  image1 : np.ndarray
      대상 영상 1
  image2 : np.ndarray
      대상 영상 2
  eq_hist : bool, optional
      명암 개선을 위해 Histogram Equalization 적용 여부
  method : str, optional
      `skimage.exposure.compare_images` 옵션
  **kwargs
      `skimage.exposure.compare_images` 옵션

  Returns
  -------
  np.ndarray

  Raises
  ------
  ValueError
      두 영상의 해상도 (shape)이 다르거나 2차원이 아닌 경우 raise
  &#34;&#34;&#34;
  if image1.shape != image2.shape:
    raise ValueError
  if image1.ndim != 2:
    raise ValueError
  if image2.ndim != 2:
    raise ValueError

  if eq_hist:
    image1 = equalize_hist(normalize_image(image1))
    image2 = equalize_hist(normalize_image(image2))

  image = compare_images(image1, image2, method=method, **kwargs)

  return image


class ImageIO:
  META_SUFFIX = &#39;_meta&#39;
  META_EXT = &#39;.yaml&#39;
  CSV_EXT = &#39;.csv&#39;
  NPY_EXT = &#39;.npy&#39;
  XLSX_EXT = &#39;.xlsx&#39;

  ENCODING = &#39;UTF-8-SIG&#39;
  DELIMITER = &#39;,&#39;

  @classmethod
  def _meta_path(cls, path: Path) -&gt; Path:
    return path.with_name(f&#39;{path.stem}{cls.META_SUFFIX}{cls.META_EXT}&#39;)

  @classmethod
  def read_image(cls, path: Union[str, Path]) -&gt; np.ndarray:
    &#34;&#34;&#34;
    주어진 path의 확장자에 따라 영상 파일 해석

    Parameters
    ----------
    path : Union[str, Path]
        대상 파일 경로. `.npy`, `.csv`, `.xlsx` 및 `.png` 등 영상 확장자 지정 가능
        (`skimage.io.imread` 참조).

    Returns
    -------
    np.ndarray

    Raises
    ------
    FileNotFoundError
        대상 파일이 존재하지 않을 때
    &#34;&#34;&#34;
    path = Path(path).resolve()
    if not path.exists():
      raise FileNotFoundError(path)

    if path.suffix == cls.NPY_EXT:
      image = np.load(file=path.as_posix())
    elif path.suffix == cls.CSV_EXT:
      image = np.loadtxt(fname=path.as_posix(), delimiter=cls.DELIMITER)
    elif path.suffix == cls.XLSX_EXT:
      image = pd.read_excel(path.as_posix())
      image = np.array(image)
    else:
      image = imread(fname=path.as_posix())

    return image

  @classmethod
  def read_image_and_meta(cls,
                          path: Union[str, Path],
                          scale=False) -&gt; Tuple[np.ndarray, Optional[dict]]:
    &#34;&#34;&#34;
    주어진 path의 확장자에 따라 영상 파일 및 메타 정보 해석.
    조건에 따라 영상의 픽셀 값을 메타 정보에 기록된 원 범위로 scale함.

    Parameters
    ----------
    path : Union[str, Path]
        대상 파일 경로
    scale : bool, optional
        `True`이며 대상 파일이 영상 확장자 (`.png` 등)인 경우,
        `save_image_and_meta` 함수로 저장된 메타 정보 파일로부터 읽은
        원본 범위로 픽셀 값을 scale함.

    Returns
    -------
    image : np.ndarray
    meta_data : Optional[dict]
    &#34;&#34;&#34;
    path = Path(path).resolve()
    image = cls.read_image(path)

    meta_path = cls._meta_path(path)
    if meta_path.exists():
      with open(meta_path, &#39;r&#39;, encoding=cls.ENCODING) as f:
        meta = yaml.safe_load(f)
    else:
      meta = None

    if scale and path.suffix not in (&#39;.csv&#39;, &#39;.npy&#39;):
      if meta is None:
        warn(f&#39;메타 정보 파일 ({meta_path.name})이 존재하지 않습니다. &#39;
             f&#39;영상의 밝기 범위를 변경하지 않습니다.&#39;)
      else:
        try:
          img_range = (meta[&#39;range&#39;][&#39;min&#39;], meta[&#39;range&#39;][&#39;max&#39;])
        except KeyError:
          warn(f&#39;메타 정보 파일 ({meta_path.name})에 영상의 밝기 정보가 없습니다. &#39;
               f&#39;영상의 밝기 범위를 변경하지 않습니다.&#39;)
        else:
          image = rescale_intensity(image=image, out_range=img_range)

    return image, meta

  @classmethod
  def save_image(cls,
                 path: Union[str, Path],
                 array: np.ndarray,
                 check_contrast=False):
    &#34;&#34;&#34;
    주어진 path의 확장자에 따라 영상 파일 저장

    Parameters
    ----------
    path : Union[str, Path]
        저장 경로. `.npy`, `.csv` 및 `.png` 등 영상 확장자 지정 가능
        (`skimage.io.imsave` 참조).
    array : np.ndarray
        저장할 영상
    check_contrast : bool, optional
        `True`인 경우, 영상 파일 확장자 저장 시 영상의 대비가 너무 낮으면 경고.
    &#34;&#34;&#34;
    path = Path(path).resolve()
    if path.suffix == cls.NPY_EXT:
      np.save(file=path.as_posix(), arr=array)
    elif path.suffix == cls.CSV_EXT:
      np.savetxt(fname=path.as_posix(), X=array, delimiter=cls.DELIMITER)
    else:
      # FIXME uint16 영상 저장 불가
      imsave(fname=path.as_posix(), arr=array, check_contrast=check_contrast)

  @staticmethod
  def _scale_and_save_image(array: np.ndarray, path: Path, exts: list):
    if not exts:
      return

    image = uint16_image(array)
    pil_image = PIL.Image.fromarray(image)

    for ext in exts:
      pil_image.save(fp=path.with_suffix(ext))

  @staticmethod
  def _save_image(array: np.ndarray, path: Path, exts: list):
    for ext in exts:
      imsave(fname=path.with_suffix(ext).as_posix(), arr=array)

  @classmethod
  def save_image_and_meta(cls,
                          path: Union[str, Path],
                          array: np.ndarray,
                          exts: list,
                          scale=False,
                          meta: Optional[dict] = None,
                          save_meta=False):
    &#34;&#34;&#34;
    주어진 path와 각 확장자 (`exts`)에 따라 영상 파일 저장.
    조건에 따라 주어진 메타 정보를 함께 저장하며, 영상 확장자 (`.png` 등) 파일은
    영상 파일 형식에 맞게 픽셀 값의 범위를 조정함.

    Parameters
    ----------
    path : Union[str, Path]
        저장 경로 (확장자는 `exts`에 따라 변경함).
    array : np.ndarray
        저장할 영상.
    exts : list
        저장할 확장자 목록.
    scale : bool, optional
        `True`인 경우, 영상 확장자 (`.png` 등) 파일은 `uint16` 범위로
        픽셀값을 조정하고 저장.
    meta : Optional[dict], optional
        영상의 메타데이터 (Exif 정보 등).
    save_meta : bool, optional
        `True`인 경우 `{file name}_meta.yaml` 파일에 메타 정보 저장.
    &#34;&#34;&#34;
    path = Path(path)

    if save_meta and meta is None:
      meta = dict()

    # npy 저장
    if cls.NPY_EXT in exts:
      np.save(file=path.with_suffix(cls.NPY_EXT).as_posix(), arr=array)
      exts.remove(cls.NPY_EXT)

    # csv 저장
    if cls.CSV_EXT in exts:
      np.savetxt(fname=path.with_suffix(cls.CSV_EXT).as_posix(),
                 X=array,
                 delimiter=cls.DELIMITER)
      exts.remove(cls.CSV_EXT)

    # 이미지 파일 저장
    if scale:
      cls._scale_and_save_image(array=array, path=path, exts=exts)
    else:
      cls._save_image(array=array, path=path, exts=exts)

    # 메타 데이터 저장
    if save_meta:
      meta[&#39;range&#39;] = {
          &#39;min&#39;: np.around(np.nanmin(array), 4).item(),
          &#39;max&#39;: np.around(np.nanmax(array), 4).item()
      }
      meta_path = cls._meta_path(path)
      with open(meta_path, &#39;w&#39;, encoding=cls.ENCODING) as f:
        yaml.safe_dump(meta, f)


def testo_convert(data_dir,
                  save_dir,
                  cmap: Optional[str] = &#39;inferno&#39;,
                  vis_suffix=&#39;_실화상 이미지.JPG&#39;):
  # TODO `pano.py` 로 옮기기

  data_dir = Path(data_dir).resolve()
  save_dir = Path(save_dir).resolve()
  ir_dir = save_dir.joinpath(&#39;IR&#39;)
  vis_dir = save_dir.joinpath(&#39;VIS&#39;)
  for d in (ir_dir, vis_dir):
    if not d.exists():
      d.mkdir()

  if cmap is not None:
    cmap = get_cmap(cmap)

  ir_files = list(data_dir.rglob(&#39;*.xlsx&#39;))
  for ir_file in track(ir_files, console=utils.console):
    vis_file = ir_file.parent.joinpath(ir_file.stem + vis_suffix)
    if not vis_file.exists():
      raise FileNotFoundError(vis_file)

    # IR npy
    ir = ImageIO.read_image(ir_file)
    ImageIO.save_image(path=ir_dir.joinpath(ir_file.stem + &#39;.npy&#39;), array=ir)

    # IR png
    if cmap is not None:
      ir_image = cmap(normalize_image(ir), bytes=True)
    else:
      ir_image = uint8_image(ir)

    ImageIO.save_image(path=ir_dir.joinpath(ir_file.stem + &#39;.png&#39;),
                       array=ir_image)

    # Visible jpg
    copy2(src=vis_file,
          dst=vis_dir.joinpath(ir_file.stem + &#39;_visible&#39; + vis_file.suffix))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="src.misc.tools.bin_size"><code class="name flex">
<span>def <span class="ident">bin_size</span></span>(<span>image1: numpy.ndarray, image2: Union[numpy.ndarray, NoneType] = None, bins='auto') ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>영상의 histogram, entropy 계산을 위한 적정 bin 개수 추정.
<code>numpy.histogram_bin_edges</code>함수를 이용함.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>image1</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>대상 영상.</dd>
<dt><strong><code>image2</code></strong> :&ensp;<code>Optional[np.ndarray]</code></dt>
<dd>
<p>대상 영상. 미입력 시 image1만 고려해서 bins 산정.</p>
<p>입력 시 image1과 image2의 적정 bins의 평균으로 결정.</p>
</dd>
<dt><strong><code>bins</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>추정 방법. <code>numpy.histogram_bin_edges</code> 참조.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>Histogram의 적정 bin 개수</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bin_size(image1: np.ndarray,
             image2: Optional[np.ndarray] = None,
             bins=&#39;auto&#39;) -&gt; int:
  &#34;&#34;&#34;
  영상의 histogram, entropy 계산을 위한 적정 bin 개수 추정.
  `numpy.histogram_bin_edges`함수를 이용함.

  Parameters
  ----------
  image1 : np.ndarray
      대상 영상.
  image2 : Optional[np.ndarray]
      대상 영상. 미입력 시 image1만 고려해서 bins 산정.

      입력 시 image1과 image2의 적정 bins의 평균으로 결정.
  bins : str, optional
      추정 방법. `numpy.histogram_bin_edges` 참조.

  Returns
  -------
  int
      Histogram의 적정 bin 개수
  &#34;&#34;&#34;
  bins_count = np.histogram_bin_edges(image1, bins=bins).size
  if image2 is not None:
    bins_count2 = np.histogram_bin_edges(image2, bins=bins).size
    bins_count = (bins_count + bins_count2) // 2

  return bins_count</code></pre>
</details>
</dd>
<dt id="src.misc.tools.mask_bbox"><code class="name flex">
<span>def <span class="ident">mask_bbox</span></span>(<span>mask: numpy.ndarray, morphology_open=True) ‑> Tuple[int, int, int, int]</span>
</code></dt>
<dd>
<div class="desc"><p>마스크 영상 중 True인 영역의 bounding box 좌표를 찾음</p>
<p>참조: <a href="https://stackoverflow.com/questions/39206986/numpy-get-rectangle-area-just-the-size-of-mask/48346079">https://stackoverflow.com/questions/39206986/numpy-get-rectangle-area-just-the-size-of-mask/48346079</a></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>mask</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>2차원 마스크. 대상 영역은 True, 대상 외 영역은 False.</dd>
<dt><strong><code>morphology_open</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Opening (morphological operation)을 통한 노이즈 제거 여부</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tuple[int, int, int, int]</code></dt>
<dd>(x_min, x_max, y_min, y_max)</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>입력한 마스크가 2차원이 아닌 경우</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mask_bbox(mask: np.ndarray,
              morphology_open=True) -&gt; Tuple[int, int, int, int]:
  &#34;&#34;&#34;
  마스크 영상 중 True인 영역의 bounding box 좌표를 찾음

  참조: https://stackoverflow.com/questions/39206986/numpy-get-rectangle-area-just-the-size-of-mask/48346079

  Parameters
  ----------
  mask : np.ndarray
      2차원 마스크. 대상 영역은 True, 대상 외 영역은 False.
  morphology_open : bool, optional
      Opening (morphological operation)을 통한 노이즈 제거 여부

  Returns
  -------
  Tuple[int, int, int, int]
      (x_min, x_max, y_min, y_max)

  Raises
  ------
  ValueError
      입력한 마스크가 2차원이 아닌 경우
  &#34;&#34;&#34;
  if mask.ndim != 2:
    raise ValueError

  if morphology_open:
    kernel = np.ones(shape=(3, 3), dtype=&#39;uint8&#39;)
    mask_ = cv.morphologyEx(src=mask, op=cv.MORPH_OPEN, kernel=kernel)
  else:
    mask_ = mask

  xx = _mask_range(mask=mask_, axis=0)
  yy = _mask_range(mask=mask_, axis=1)

  return xx + yy</code></pre>
</details>
</dd>
<dt id="src.misc.tools.normalize_image"><code class="name flex">
<span>def <span class="ident">normalize_image</span></span>(<span>image: numpy.ndarray) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>영상의 pixel 값을 [0.0, 1.0] 범위로 정규화</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>image</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>대상 영상</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normalize_image(image: np.ndarray) -&gt; np.ndarray:
  &#34;&#34;&#34;
  영상의 pixel 값을 [0.0, 1.0] 범위로 정규화

  Parameters
  ----------
  image : np.ndarray
      대상 영상

  Returns
  -------
  np.ndarray
  &#34;&#34;&#34;
  return rescale_intensity(image=image, out_range=(0.0, 1.0))</code></pre>
</details>
</dd>
<dt id="src.misc.tools.normalize_rgb_image_hist"><code class="name flex">
<span>def <span class="ident">normalize_rgb_image_hist</span></span>(<span>image: numpy.ndarray) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>밝기 정규화를 통해 컬러 영상의 명암비 개선</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>image</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>RGB uint8 영상</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normalize_rgb_image_hist(image: np.ndarray) -&gt; np.ndarray:
  &#34;&#34;&#34;
  밝기 정규화를 통해 컬러 영상의 명암비 개선

  Parameters
  ----------
  image : np.ndarray
      RGB uint8 영상

  Returns
  -------
  np.ndarray
  &#34;&#34;&#34;
  image_yuv = cv.cvtColor(image, cv.COLOR_RGB2YUV)
  image_yuv[:, :, 0] = cv.normalize(image_yuv[:, :, 0],
                                    dst=None,
                                    alpha=0,
                                    beta=255,
                                    norm_type=cv.NORM_MINMAX)
  equalized = cv.cvtColor(image_yuv, cv.COLOR_YUV2RGB)

  return equalized</code></pre>
</details>
</dd>
<dt id="src.misc.tools.prep_compare_images"><code class="name flex">
<span>def <span class="ident">prep_compare_images</span></span>(<span>image1: numpy.ndarray, image2: numpy.ndarray, eq_hist=True, method='checkerboard', **kwargs) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>두 영상의 전처리 및 비교 영상 생성.
두 영상 모두 2차원 (gray image)이며 해상도 (ndarray.shape)이 동일해야 함.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>image1</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>대상 영상 1</dd>
<dt><strong><code>image2</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>대상 영상 2</dd>
<dt><strong><code>eq_hist</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>명암 개선을 위해 Histogram Equalization 적용 여부</dd>
<dt><strong><code>method</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd><code>skimage.exposure.compare_images</code> 옵션</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd><code>skimage.exposure.compare_images</code> 옵션</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>두 영상의 해상도 (shape)이 다르거나 2차원이 아닌 경우 raise</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prep_compare_images(image1: np.ndarray,
                        image2: np.ndarray,
                        eq_hist=True,
                        method=&#39;checkerboard&#39;,
                        **kwargs) -&gt; np.ndarray:
  &#34;&#34;&#34;
  두 영상의 전처리 및 비교 영상 생성.
  두 영상 모두 2차원 (gray image)이며 해상도 (ndarray.shape)이 동일해야 함.

  Parameters
  ----------
  image1 : np.ndarray
      대상 영상 1
  image2 : np.ndarray
      대상 영상 2
  eq_hist : bool, optional
      명암 개선을 위해 Histogram Equalization 적용 여부
  method : str, optional
      `skimage.exposure.compare_images` 옵션
  **kwargs
      `skimage.exposure.compare_images` 옵션

  Returns
  -------
  np.ndarray

  Raises
  ------
  ValueError
      두 영상의 해상도 (shape)이 다르거나 2차원이 아닌 경우 raise
  &#34;&#34;&#34;
  if image1.shape != image2.shape:
    raise ValueError
  if image1.ndim != 2:
    raise ValueError
  if image2.ndim != 2:
    raise ValueError

  if eq_hist:
    image1 = equalize_hist(normalize_image(image1))
    image2 = equalize_hist(normalize_image(image2))

  image = compare_images(image1, image2, method=method, **kwargs)

  return image</code></pre>
</details>
</dd>
<dt id="src.misc.tools.testo_convert"><code class="name flex">
<span>def <span class="ident">testo_convert</span></span>(<span>data_dir, save_dir, cmap: Union[str, NoneType] = 'inferno', vis_suffix='_실화상 이미지.JPG')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testo_convert(data_dir,
                  save_dir,
                  cmap: Optional[str] = &#39;inferno&#39;,
                  vis_suffix=&#39;_실화상 이미지.JPG&#39;):
  # TODO `pano.py` 로 옮기기

  data_dir = Path(data_dir).resolve()
  save_dir = Path(save_dir).resolve()
  ir_dir = save_dir.joinpath(&#39;IR&#39;)
  vis_dir = save_dir.joinpath(&#39;VIS&#39;)
  for d in (ir_dir, vis_dir):
    if not d.exists():
      d.mkdir()

  if cmap is not None:
    cmap = get_cmap(cmap)

  ir_files = list(data_dir.rglob(&#39;*.xlsx&#39;))
  for ir_file in track(ir_files, console=utils.console):
    vis_file = ir_file.parent.joinpath(ir_file.stem + vis_suffix)
    if not vis_file.exists():
      raise FileNotFoundError(vis_file)

    # IR npy
    ir = ImageIO.read_image(ir_file)
    ImageIO.save_image(path=ir_dir.joinpath(ir_file.stem + &#39;.npy&#39;), array=ir)

    # IR png
    if cmap is not None:
      ir_image = cmap(normalize_image(ir), bytes=True)
    else:
      ir_image = uint8_image(ir)

    ImageIO.save_image(path=ir_dir.joinpath(ir_file.stem + &#39;.png&#39;),
                       array=ir_image)

    # Visible jpg
    copy2(src=vis_file,
          dst=vis_dir.joinpath(ir_file.stem + &#39;_visible&#39; + vis_file.suffix))</code></pre>
</details>
</dd>
<dt id="src.misc.tools.uint16_image"><code class="name flex">
<span>def <span class="ident">uint16_image</span></span>(<span>image: numpy.ndarray) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def uint16_image(image: np.ndarray) -&gt; np.ndarray:
  return rescale_intensity(image, out_range=&#39;uint16&#39;)</code></pre>
</details>
</dd>
<dt id="src.misc.tools.uint8_image"><code class="name flex">
<span>def <span class="ident">uint8_image</span></span>(<span>image: numpy.ndarray) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def uint8_image(image: np.ndarray) -&gt; np.ndarray:
  return rescale_intensity(image, out_range=&#39;uint8&#39;)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="src.misc.tools.ImageIO"><code class="flex name class">
<span>class <span class="ident">ImageIO</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ImageIO:
  META_SUFFIX = &#39;_meta&#39;
  META_EXT = &#39;.yaml&#39;
  CSV_EXT = &#39;.csv&#39;
  NPY_EXT = &#39;.npy&#39;
  XLSX_EXT = &#39;.xlsx&#39;

  ENCODING = &#39;UTF-8-SIG&#39;
  DELIMITER = &#39;,&#39;

  @classmethod
  def _meta_path(cls, path: Path) -&gt; Path:
    return path.with_name(f&#39;{path.stem}{cls.META_SUFFIX}{cls.META_EXT}&#39;)

  @classmethod
  def read_image(cls, path: Union[str, Path]) -&gt; np.ndarray:
    &#34;&#34;&#34;
    주어진 path의 확장자에 따라 영상 파일 해석

    Parameters
    ----------
    path : Union[str, Path]
        대상 파일 경로. `.npy`, `.csv`, `.xlsx` 및 `.png` 등 영상 확장자 지정 가능
        (`skimage.io.imread` 참조).

    Returns
    -------
    np.ndarray

    Raises
    ------
    FileNotFoundError
        대상 파일이 존재하지 않을 때
    &#34;&#34;&#34;
    path = Path(path).resolve()
    if not path.exists():
      raise FileNotFoundError(path)

    if path.suffix == cls.NPY_EXT:
      image = np.load(file=path.as_posix())
    elif path.suffix == cls.CSV_EXT:
      image = np.loadtxt(fname=path.as_posix(), delimiter=cls.DELIMITER)
    elif path.suffix == cls.XLSX_EXT:
      image = pd.read_excel(path.as_posix())
      image = np.array(image)
    else:
      image = imread(fname=path.as_posix())

    return image

  @classmethod
  def read_image_and_meta(cls,
                          path: Union[str, Path],
                          scale=False) -&gt; Tuple[np.ndarray, Optional[dict]]:
    &#34;&#34;&#34;
    주어진 path의 확장자에 따라 영상 파일 및 메타 정보 해석.
    조건에 따라 영상의 픽셀 값을 메타 정보에 기록된 원 범위로 scale함.

    Parameters
    ----------
    path : Union[str, Path]
        대상 파일 경로
    scale : bool, optional
        `True`이며 대상 파일이 영상 확장자 (`.png` 등)인 경우,
        `save_image_and_meta` 함수로 저장된 메타 정보 파일로부터 읽은
        원본 범위로 픽셀 값을 scale함.

    Returns
    -------
    image : np.ndarray
    meta_data : Optional[dict]
    &#34;&#34;&#34;
    path = Path(path).resolve()
    image = cls.read_image(path)

    meta_path = cls._meta_path(path)
    if meta_path.exists():
      with open(meta_path, &#39;r&#39;, encoding=cls.ENCODING) as f:
        meta = yaml.safe_load(f)
    else:
      meta = None

    if scale and path.suffix not in (&#39;.csv&#39;, &#39;.npy&#39;):
      if meta is None:
        warn(f&#39;메타 정보 파일 ({meta_path.name})이 존재하지 않습니다. &#39;
             f&#39;영상의 밝기 범위를 변경하지 않습니다.&#39;)
      else:
        try:
          img_range = (meta[&#39;range&#39;][&#39;min&#39;], meta[&#39;range&#39;][&#39;max&#39;])
        except KeyError:
          warn(f&#39;메타 정보 파일 ({meta_path.name})에 영상의 밝기 정보가 없습니다. &#39;
               f&#39;영상의 밝기 범위를 변경하지 않습니다.&#39;)
        else:
          image = rescale_intensity(image=image, out_range=img_range)

    return image, meta

  @classmethod
  def save_image(cls,
                 path: Union[str, Path],
                 array: np.ndarray,
                 check_contrast=False):
    &#34;&#34;&#34;
    주어진 path의 확장자에 따라 영상 파일 저장

    Parameters
    ----------
    path : Union[str, Path]
        저장 경로. `.npy`, `.csv` 및 `.png` 등 영상 확장자 지정 가능
        (`skimage.io.imsave` 참조).
    array : np.ndarray
        저장할 영상
    check_contrast : bool, optional
        `True`인 경우, 영상 파일 확장자 저장 시 영상의 대비가 너무 낮으면 경고.
    &#34;&#34;&#34;
    path = Path(path).resolve()
    if path.suffix == cls.NPY_EXT:
      np.save(file=path.as_posix(), arr=array)
    elif path.suffix == cls.CSV_EXT:
      np.savetxt(fname=path.as_posix(), X=array, delimiter=cls.DELIMITER)
    else:
      # FIXME uint16 영상 저장 불가
      imsave(fname=path.as_posix(), arr=array, check_contrast=check_contrast)

  @staticmethod
  def _scale_and_save_image(array: np.ndarray, path: Path, exts: list):
    if not exts:
      return

    image = uint16_image(array)
    pil_image = PIL.Image.fromarray(image)

    for ext in exts:
      pil_image.save(fp=path.with_suffix(ext))

  @staticmethod
  def _save_image(array: np.ndarray, path: Path, exts: list):
    for ext in exts:
      imsave(fname=path.with_suffix(ext).as_posix(), arr=array)

  @classmethod
  def save_image_and_meta(cls,
                          path: Union[str, Path],
                          array: np.ndarray,
                          exts: list,
                          scale=False,
                          meta: Optional[dict] = None,
                          save_meta=False):
    &#34;&#34;&#34;
    주어진 path와 각 확장자 (`exts`)에 따라 영상 파일 저장.
    조건에 따라 주어진 메타 정보를 함께 저장하며, 영상 확장자 (`.png` 등) 파일은
    영상 파일 형식에 맞게 픽셀 값의 범위를 조정함.

    Parameters
    ----------
    path : Union[str, Path]
        저장 경로 (확장자는 `exts`에 따라 변경함).
    array : np.ndarray
        저장할 영상.
    exts : list
        저장할 확장자 목록.
    scale : bool, optional
        `True`인 경우, 영상 확장자 (`.png` 등) 파일은 `uint16` 범위로
        픽셀값을 조정하고 저장.
    meta : Optional[dict], optional
        영상의 메타데이터 (Exif 정보 등).
    save_meta : bool, optional
        `True`인 경우 `{file name}_meta.yaml` 파일에 메타 정보 저장.
    &#34;&#34;&#34;
    path = Path(path)

    if save_meta and meta is None:
      meta = dict()

    # npy 저장
    if cls.NPY_EXT in exts:
      np.save(file=path.with_suffix(cls.NPY_EXT).as_posix(), arr=array)
      exts.remove(cls.NPY_EXT)

    # csv 저장
    if cls.CSV_EXT in exts:
      np.savetxt(fname=path.with_suffix(cls.CSV_EXT).as_posix(),
                 X=array,
                 delimiter=cls.DELIMITER)
      exts.remove(cls.CSV_EXT)

    # 이미지 파일 저장
    if scale:
      cls._scale_and_save_image(array=array, path=path, exts=exts)
    else:
      cls._save_image(array=array, path=path, exts=exts)

    # 메타 데이터 저장
    if save_meta:
      meta[&#39;range&#39;] = {
          &#39;min&#39;: np.around(np.nanmin(array), 4).item(),
          &#39;max&#39;: np.around(np.nanmax(array), 4).item()
      }
      meta_path = cls._meta_path(path)
      with open(meta_path, &#39;w&#39;, encoding=cls.ENCODING) as f:
        yaml.safe_dump(meta, f)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="src.misc.tools.ImageIO.CSV_EXT"><code class="name">var <span class="ident">CSV_EXT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.misc.tools.ImageIO.DELIMITER"><code class="name">var <span class="ident">DELIMITER</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.misc.tools.ImageIO.ENCODING"><code class="name">var <span class="ident">ENCODING</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.misc.tools.ImageIO.META_EXT"><code class="name">var <span class="ident">META_EXT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.misc.tools.ImageIO.META_SUFFIX"><code class="name">var <span class="ident">META_SUFFIX</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.misc.tools.ImageIO.NPY_EXT"><code class="name">var <span class="ident">NPY_EXT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.misc.tools.ImageIO.XLSX_EXT"><code class="name">var <span class="ident">XLSX_EXT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="src.misc.tools.ImageIO.read_image"><code class="name flex">
<span>def <span class="ident">read_image</span></span>(<span>path: Union[str, pathlib.Path]) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>주어진 path의 확장자에 따라 영상 파일 해석</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>Union[str, Path]</code></dt>
<dd>대상 파일 경로. <code>.npy</code>, <code>.csv</code>, <code>.xlsx</code> 및 <code>.png</code> 등 영상 확장자 지정 가능
(<code>skimage.io.imread</code> 참조).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>FileNotFoundError</code></dt>
<dd>대상 파일이 존재하지 않을 때</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def read_image(cls, path: Union[str, Path]) -&gt; np.ndarray:
  &#34;&#34;&#34;
  주어진 path의 확장자에 따라 영상 파일 해석

  Parameters
  ----------
  path : Union[str, Path]
      대상 파일 경로. `.npy`, `.csv`, `.xlsx` 및 `.png` 등 영상 확장자 지정 가능
      (`skimage.io.imread` 참조).

  Returns
  -------
  np.ndarray

  Raises
  ------
  FileNotFoundError
      대상 파일이 존재하지 않을 때
  &#34;&#34;&#34;
  path = Path(path).resolve()
  if not path.exists():
    raise FileNotFoundError(path)

  if path.suffix == cls.NPY_EXT:
    image = np.load(file=path.as_posix())
  elif path.suffix == cls.CSV_EXT:
    image = np.loadtxt(fname=path.as_posix(), delimiter=cls.DELIMITER)
  elif path.suffix == cls.XLSX_EXT:
    image = pd.read_excel(path.as_posix())
    image = np.array(image)
  else:
    image = imread(fname=path.as_posix())

  return image</code></pre>
</details>
</dd>
<dt id="src.misc.tools.ImageIO.read_image_and_meta"><code class="name flex">
<span>def <span class="ident">read_image_and_meta</span></span>(<span>path: Union[str, pathlib.Path], scale=False) ‑> Tuple[numpy.ndarray, Union[dict, NoneType]]</span>
</code></dt>
<dd>
<div class="desc"><p>주어진 path의 확장자에 따라 영상 파일 및 메타 정보 해석.
조건에 따라 영상의 픽셀 값을 메타 정보에 기록된 원 범위로 scale함.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>Union[str, Path]</code></dt>
<dd>대상 파일 경로</dd>
<dt><strong><code>scale</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd><code>True</code>이며 대상 파일이 영상 확장자 (<code>.png</code> 등)인 경우,
<code>save_image_and_meta</code> 함수로 저장된 메타 정보 파일로부터 읽은
원본 범위로 픽셀 값을 scale함.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>image</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>meta_data</code></strong> :&ensp;<code>Optional[dict]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def read_image_and_meta(cls,
                        path: Union[str, Path],
                        scale=False) -&gt; Tuple[np.ndarray, Optional[dict]]:
  &#34;&#34;&#34;
  주어진 path의 확장자에 따라 영상 파일 및 메타 정보 해석.
  조건에 따라 영상의 픽셀 값을 메타 정보에 기록된 원 범위로 scale함.

  Parameters
  ----------
  path : Union[str, Path]
      대상 파일 경로
  scale : bool, optional
      `True`이며 대상 파일이 영상 확장자 (`.png` 등)인 경우,
      `save_image_and_meta` 함수로 저장된 메타 정보 파일로부터 읽은
      원본 범위로 픽셀 값을 scale함.

  Returns
  -------
  image : np.ndarray
  meta_data : Optional[dict]
  &#34;&#34;&#34;
  path = Path(path).resolve()
  image = cls.read_image(path)

  meta_path = cls._meta_path(path)
  if meta_path.exists():
    with open(meta_path, &#39;r&#39;, encoding=cls.ENCODING) as f:
      meta = yaml.safe_load(f)
  else:
    meta = None

  if scale and path.suffix not in (&#39;.csv&#39;, &#39;.npy&#39;):
    if meta is None:
      warn(f&#39;메타 정보 파일 ({meta_path.name})이 존재하지 않습니다. &#39;
           f&#39;영상의 밝기 범위를 변경하지 않습니다.&#39;)
    else:
      try:
        img_range = (meta[&#39;range&#39;][&#39;min&#39;], meta[&#39;range&#39;][&#39;max&#39;])
      except KeyError:
        warn(f&#39;메타 정보 파일 ({meta_path.name})에 영상의 밝기 정보가 없습니다. &#39;
             f&#39;영상의 밝기 범위를 변경하지 않습니다.&#39;)
      else:
        image = rescale_intensity(image=image, out_range=img_range)

  return image, meta</code></pre>
</details>
</dd>
<dt id="src.misc.tools.ImageIO.save_image"><code class="name flex">
<span>def <span class="ident">save_image</span></span>(<span>path: Union[str, pathlib.Path], array: numpy.ndarray, check_contrast=False)</span>
</code></dt>
<dd>
<div class="desc"><p>주어진 path의 확장자에 따라 영상 파일 저장</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>Union[str, Path]</code></dt>
<dd>저장 경로. <code>.npy</code>, <code>.csv</code> 및 <code>.png</code> 등 영상 확장자 지정 가능
(<code>skimage.io.imsave</code> 참조).</dd>
<dt><strong><code>array</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>저장할 영상</dd>
<dt><strong><code>check_contrast</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd><code>True</code>인 경우, 영상 파일 확장자 저장 시 영상의 대비가 너무 낮으면 경고.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def save_image(cls,
               path: Union[str, Path],
               array: np.ndarray,
               check_contrast=False):
  &#34;&#34;&#34;
  주어진 path의 확장자에 따라 영상 파일 저장

  Parameters
  ----------
  path : Union[str, Path]
      저장 경로. `.npy`, `.csv` 및 `.png` 등 영상 확장자 지정 가능
      (`skimage.io.imsave` 참조).
  array : np.ndarray
      저장할 영상
  check_contrast : bool, optional
      `True`인 경우, 영상 파일 확장자 저장 시 영상의 대비가 너무 낮으면 경고.
  &#34;&#34;&#34;
  path = Path(path).resolve()
  if path.suffix == cls.NPY_EXT:
    np.save(file=path.as_posix(), arr=array)
  elif path.suffix == cls.CSV_EXT:
    np.savetxt(fname=path.as_posix(), X=array, delimiter=cls.DELIMITER)
  else:
    # FIXME uint16 영상 저장 불가
    imsave(fname=path.as_posix(), arr=array, check_contrast=check_contrast)</code></pre>
</details>
</dd>
<dt id="src.misc.tools.ImageIO.save_image_and_meta"><code class="name flex">
<span>def <span class="ident">save_image_and_meta</span></span>(<span>path: Union[str, pathlib.Path], array: numpy.ndarray, exts: list, scale=False, meta: Union[dict, NoneType] = None, save_meta=False)</span>
</code></dt>
<dd>
<div class="desc"><p>주어진 path와 각 확장자 (<code>exts</code>)에 따라 영상 파일 저장.
조건에 따라 주어진 메타 정보를 함께 저장하며, 영상 확장자 (<code>.png</code> 등) 파일은
영상 파일 형식에 맞게 픽셀 값의 범위를 조정함.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>Union[str, Path]</code></dt>
<dd>저장 경로 (확장자는 <code>exts</code>에 따라 변경함).</dd>
<dt><strong><code>array</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>저장할 영상.</dd>
<dt><strong><code>exts</code></strong> :&ensp;<code>list</code></dt>
<dd>저장할 확장자 목록.</dd>
<dt><strong><code>scale</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd><code>True</code>인 경우, 영상 확장자 (<code>.png</code> 등) 파일은 <code>uint16</code> 범위로
픽셀값을 조정하고 저장.</dd>
<dt><strong><code>meta</code></strong> :&ensp;<code>Optional[dict]</code>, optional</dt>
<dd>영상의 메타데이터 (Exif 정보 등).</dd>
<dt><strong><code>save_meta</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd><code>True</code>인 경우 <code>{file name}_meta.yaml</code> 파일에 메타 정보 저장.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def save_image_and_meta(cls,
                        path: Union[str, Path],
                        array: np.ndarray,
                        exts: list,
                        scale=False,
                        meta: Optional[dict] = None,
                        save_meta=False):
  &#34;&#34;&#34;
  주어진 path와 각 확장자 (`exts`)에 따라 영상 파일 저장.
  조건에 따라 주어진 메타 정보를 함께 저장하며, 영상 확장자 (`.png` 등) 파일은
  영상 파일 형식에 맞게 픽셀 값의 범위를 조정함.

  Parameters
  ----------
  path : Union[str, Path]
      저장 경로 (확장자는 `exts`에 따라 변경함).
  array : np.ndarray
      저장할 영상.
  exts : list
      저장할 확장자 목록.
  scale : bool, optional
      `True`인 경우, 영상 확장자 (`.png` 등) 파일은 `uint16` 범위로
      픽셀값을 조정하고 저장.
  meta : Optional[dict], optional
      영상의 메타데이터 (Exif 정보 등).
  save_meta : bool, optional
      `True`인 경우 `{file name}_meta.yaml` 파일에 메타 정보 저장.
  &#34;&#34;&#34;
  path = Path(path)

  if save_meta and meta is None:
    meta = dict()

  # npy 저장
  if cls.NPY_EXT in exts:
    np.save(file=path.with_suffix(cls.NPY_EXT).as_posix(), arr=array)
    exts.remove(cls.NPY_EXT)

  # csv 저장
  if cls.CSV_EXT in exts:
    np.savetxt(fname=path.with_suffix(cls.CSV_EXT).as_posix(),
               X=array,
               delimiter=cls.DELIMITER)
    exts.remove(cls.CSV_EXT)

  # 이미지 파일 저장
  if scale:
    cls._scale_and_save_image(array=array, path=path, exts=exts)
  else:
    cls._save_image(array=array, path=path, exts=exts)

  # 메타 데이터 저장
  if save_meta:
    meta[&#39;range&#39;] = {
        &#39;min&#39;: np.around(np.nanmin(array), 4).item(),
        &#39;max&#39;: np.around(np.nanmax(array), 4).item()
    }
    meta_path = cls._meta_path(path)
    with open(meta_path, &#39;w&#39;, encoding=cls.ENCODING) as f:
      yaml.safe_dump(meta, f)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="src.misc" href="index.html">src.misc</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="src.misc.tools.bin_size" href="#src.misc.tools.bin_size">bin_size</a></code></li>
<li><code><a title="src.misc.tools.mask_bbox" href="#src.misc.tools.mask_bbox">mask_bbox</a></code></li>
<li><code><a title="src.misc.tools.normalize_image" href="#src.misc.tools.normalize_image">normalize_image</a></code></li>
<li><code><a title="src.misc.tools.normalize_rgb_image_hist" href="#src.misc.tools.normalize_rgb_image_hist">normalize_rgb_image_hist</a></code></li>
<li><code><a title="src.misc.tools.prep_compare_images" href="#src.misc.tools.prep_compare_images">prep_compare_images</a></code></li>
<li><code><a title="src.misc.tools.testo_convert" href="#src.misc.tools.testo_convert">testo_convert</a></code></li>
<li><code><a title="src.misc.tools.uint16_image" href="#src.misc.tools.uint16_image">uint16_image</a></code></li>
<li><code><a title="src.misc.tools.uint8_image" href="#src.misc.tools.uint8_image">uint8_image</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="src.misc.tools.ImageIO" href="#src.misc.tools.ImageIO">ImageIO</a></code></h4>
<ul class="two-column">
<li><code><a title="src.misc.tools.ImageIO.CSV_EXT" href="#src.misc.tools.ImageIO.CSV_EXT">CSV_EXT</a></code></li>
<li><code><a title="src.misc.tools.ImageIO.DELIMITER" href="#src.misc.tools.ImageIO.DELIMITER">DELIMITER</a></code></li>
<li><code><a title="src.misc.tools.ImageIO.ENCODING" href="#src.misc.tools.ImageIO.ENCODING">ENCODING</a></code></li>
<li><code><a title="src.misc.tools.ImageIO.META_EXT" href="#src.misc.tools.ImageIO.META_EXT">META_EXT</a></code></li>
<li><code><a title="src.misc.tools.ImageIO.META_SUFFIX" href="#src.misc.tools.ImageIO.META_SUFFIX">META_SUFFIX</a></code></li>
<li><code><a title="src.misc.tools.ImageIO.NPY_EXT" href="#src.misc.tools.ImageIO.NPY_EXT">NPY_EXT</a></code></li>
<li><code><a title="src.misc.tools.ImageIO.XLSX_EXT" href="#src.misc.tools.ImageIO.XLSX_EXT">XLSX_EXT</a></code></li>
<li><code><a title="src.misc.tools.ImageIO.read_image" href="#src.misc.tools.ImageIO.read_image">read_image</a></code></li>
<li><code><a title="src.misc.tools.ImageIO.read_image_and_meta" href="#src.misc.tools.ImageIO.read_image_and_meta">read_image_and_meta</a></code></li>
<li><code><a title="src.misc.tools.ImageIO.save_image" href="#src.misc.tools.ImageIO.save_image">save_image</a></code></li>
<li><code><a title="src.misc.tools.ImageIO.save_image_and_meta" href="#src.misc.tools.ImageIO.save_image_and_meta">save_image_and_meta</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>