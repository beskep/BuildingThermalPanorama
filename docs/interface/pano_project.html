<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>pano.interface.pano_project API documentation</title>
<meta name="description" content="외피 열화상 파노라마 영상처리 알고리즘의 CLI 인터페이스" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pano.interface.pano_project</code></h1>
</header>
<section id="section-intro">
<p>외피 열화상 파노라마 영상처리 알고리즘의 CLI 인터페이스</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;외피 열화상 파노라마 영상처리 알고리즘의 CLI 인터페이스&#34;&#34;&#34;

from pathlib import Path
from typing import Callable, List, Optional, Union

from loguru import logger
import matplotlib.pyplot as plt
import numpy as np
from rich.progress import track

from pano import flir
from pano import stitch
from pano import utils
from pano.distortion import perspective as persp
from pano.misc import exif
from pano.misc import tools
from pano.misc.imageio import ImageIO as IIO
import pano.registration.registrator.simpleitk as rsitk

from .common.cmap import apply_colormap
from .common.cmap import get_thermal_colormap
from .common.config import DictConfig
from .common.config import set_config
from .common.pano_files import DIR
from .common.pano_files import FN
from .common.pano_files import SP
from .common.pano_files import ThermalPanoramaFileManager


class ThermalPanorama:
  _SP_DIR = {
      SP.IR.value: DIR.IR,
      SP.VIS.value: DIR.RGST,
      SP.SEG.value: DIR.SEG,
  }
  _SP_KOR = {
      SP.IR.value: &#39;열화상&#39;,
      SP.VIS.value: &#39;실화상&#39;,
      SP.SEG.value: &#39;부위 인식&#39;,
  }

  def __init__(self, directory: Union[str, Path], default_config=False) -&gt; None:
    # working directory
    wd = Path(directory).resolve()
    if not wd.exists():
      raise FileNotFoundError(wd)

    self._wd = wd
    self._config = set_config(directory=wd, default=default_config)
    self._fm = ThermalPanoramaFileManager(directory=wd)

    # 제조사, Raw 파일 패턴
    self._manufacturer = self._check_manufacturer()
    self._fm.raw_pattern = self._config[&#39;file&#39;][self._manufacturer][&#39;IR&#39;]
    if self._manufacturer != &#39;FLIR&#39;:
      self._flir_ext = None
    else:
      self._flir_ext = flir.FlirExtractor()
    logger.info(&#39;Manufacturer: {}&#39;, self._manufacturer)

    # 카메라 기종
    self._camera = self._check_camera_model()
    logger.info(&#39;Camera: {}&#39;, self._camera)

    # 컬러맵
    self._cmap = get_thermal_colormap(
        name=self._config[&#39;color&#39;].get(&#39;colormap&#39;, &#39;iron&#39;))

  def _check_manufacturer(self) -&gt; str:
    fopt: DictConfig = self._config[&#39;file&#39;]
    flir_files = self._fm.glob(d=DIR.RAW, pattern=fopt[&#39;FLIR&#39;][&#39;IR&#39;])
    testo_ir_files = self._fm.glob(d=DIR.RAW, pattern=fopt[&#39;testo&#39;][&#39;IR&#39;])
    testo_vis_files = self._fm.glob(d=DIR.RAW, pattern=fopt[&#39;testo&#39;][&#39;VIS&#39;])

    if testo_ir_files and testo_vis_files:
      manufacturer = &#39;testo&#39;
    elif flir_files:
      manufacturer = &#39;FLIR&#39;
    else:
      raise ValueError(&#39;지원하지 않는 Raw 파일 형식입니다.&#39;)

    return manufacturer

  def _check_camera_model(self) -&gt; Optional[str]:
    tags = [&#39;Model&#39;, &#39;CameraModel&#39;]
    raw_files = self._fm.raw_files()

    def _get_model(exif: dict):
      # iterable 중 조건을 만족하는 첫 element
      tag = next((x for x in exif.keys() if x in tags), None)
      if tag is None:
        return None

      return exif[tag]

    exifs = exif.get_exif(files=[x.as_posix() for x in raw_files], tags=tags)
    models = [_get_model(x) for x in exifs]
    models = [x for x in models if x is not None]

    if not models:
      logger.debug(&#39;Exif로부터 카메라 기종 추정 불가&#39;)
      return None

    if any(models[0] != x for x in models[1:]):
      logger.warning(&#39;다수의 카메라로 촬영된 Raw 파일을 입력했습니다 ({}). &#39;
                     &#39;카메라 기종을 추정할 수 없습니다.&#39;, set(models))
      return None

    return models[0]

  def _extract_flir_image(self, path: Path):
    assert self._flir_ext is not None
    ir, vis = self._flir_ext.extract_data(path)
    meta = {&#39;Exif&#39;: exif.get_exif(files=path.as_posix())[0]}

    if self._config[&#39;file&#39;][&#39;force_horizontal&#39;] and (ir.shape[0] &gt; ir.shape[1]):
      # 수직 영상을 수평으로 만들기 위해 90도 회전
      if self._config[&#39;file&#39;][&#39;force_horizontal&#39;] == &#39;CCW&#39;:
        k = 1
      elif self._config[&#39;file&#39;][&#39;force_horizontal&#39;] == &#39;CW&#39;:
        k = 3
      else:
        raise ValueError(&#39;&#34;force_horizontal must be one of {&#34;CW&#34;, &#34;CCW&#34;}&#39;)

      logger.debug(&#39;Rotate &#34;{}&#34; (k={})&#39;, path.name, k)
      ir = np.rot90(ir, k=k, axes=(0, 1))
      vis = np.rot90(vis, k=k, axes=(0, 1))

    # FLIR One로 찍은 사진은 수직으로 촬영해도 orientation 번호가
    # `1` (`Horizontal (normal)`)로 표시되어서 아래 정보가 쓸모가 없음...

    # tag = exif.get_exif_tags(path.as_posix(), &#39;-Orientation&#39;, &#39;-n&#39;)
    # orientation = tag[&#39;Orientation&#39;]

    return ir, vis, meta

  def _extract_testo_image(self, path: Path):
    vis_suffix = self._config[&#39;file&#39;][&#39;testo&#39;][&#39;VIS&#39;].replace(&#39;*&#39;, &#39;&#39;)
    vis_path = path.with_name(path.stem + vis_suffix)

    ir = IIO.read(path=path)
    vis = IIO.read(path=vis_path)

    return ir, vis

  def _save_extracted_image(self,
                            fname: str,
                            ir: np.ndarray,
                            vis: np.ndarray,
                            meta: Optional[dict] = None):
    &#34;&#34;&#34;추출한 열/실화상을 각 폴더에 저장&#34;&#34;&#34;
    ir_path = self._fm.change_dir(DIR.IR, file=fname)
    vis_path = self._fm.change_dir(DIR.VIS, file=fname)

    IIO.save_with_meta(path=ir_path, array=ir, exts=[FN.NPY], meta=meta)

    if self._config[&#39;color&#39;][&#39;extract_color_image&#39;]:
      color_image = apply_colormap(ir, self._cmap)
      IIO.save(path=self._fm.color_path(ir_path), array=color_image)

    IIO.save(path=vis_path, array=vis)

  def _extract_raw_file(self, file: Path):
    &#34;&#34;&#34;
    Raw 열화상, 실화상 파일 추출.

    Parameters
    ----------
    file : Path
        Raw 파일 경로
    &#34;&#34;&#34;
    if not file.exists():
      raise FileNotFoundError(file)

    ir_path = self._fm.change_dir(DIR.IR, file)
    vis_path = self._fm.change_dir(DIR.VIS, file)
    if ir_path.exists() and vis_path.exists():
      return

    logger.debug(&#39;Extracting &#34;{}&#34;&#39;, file.name)

    if self._manufacturer == &#39;FLIR&#39;:
      ir, vis, meta = self._extract_flir_image(path=file)
    elif self._manufacturer == &#39;testo&#39;:
      ir, vis = self._extract_testo_image(path=file)
      meta = None
    else:
      raise ValueError

    assert ir is not None
    self._save_extracted_image(fname=file.stem, ir=ir, vis=vis, meta=meta)

  def extract(self):
    try:
      self._fm.files(DIR.IR)
      self._fm.files(DIR.VIS)
    except FileNotFoundError:
      self._fm.subdir(DIR.IR, mkdir=True)
      self._fm.subdir(DIR.VIS, mkdir=True)

      files = self._fm.raw_files()
      for file in utils.track(files, description=&#39;Extracting images...&#39;):
        self._extract_raw_file(file=file)

  def extract_generator(self):
    try:
      self._fm.files(DIR.IR)
      self._fm.files(DIR.VIS)
    except FileNotFoundError:
      self._fm.subdir(DIR.IR, mkdir=True)
      self._fm.subdir(DIR.VIS, mkdir=True)

      files = self._fm.raw_files()
      for r, file in utils.ptrack(files, description=&#39;Extracting images...&#39;):
        self._extract_raw_file(file=file)
        yield r

  @property
  def _size_limit(self):
    return self._config[&#39;file&#39;][&#39;size_limit&#39;]

  def limit_size(self, image: np.ndarray) -&gt; np.ndarray:
    return tools.limit_image_size(image=image, limit=self._size_limit)

  def _init_registrator(self, shape):
    ropt: DictConfig = self._config[&#39;registration&#39;]

    if self._camera in self._config[&#39;camera&#39;]:
      camera = self._camera
    else:
      camera = &#39;default&#39;

    copt: DictConfig = self._config[&#39;camera&#39;][camera]
    logger.debug(&#39;Regestering preset: {}&#39;, camera)

    trsf = rsitk.Transformation[ropt[&#39;transformation&#39;]]
    metric = rsitk.Metric[ropt[&#39;metric&#39;]]
    optimizer = ropt[&#39;optimizer&#39;]

    registrator = rsitk.SITKRegistrator(transformation=trsf,
                                        metric=metric,
                                        optimizer=optimizer,
                                        bins=ropt[&#39;bins&#39;])
    aov = [
        np.deg2rad(copt[x]) if copt[x] else None for x in [&#39;IR_AOV&#39;, &#39;VIS_AOV&#39;]
    ]
    registrator.set_initial_params(scale=copt[&#39;scale&#39;],
                                   fixed_alpha=aov[0],
                                   moving_alpha=aov[1],
                                   translation=copt[&#39;translation&#39;])
    prep = rsitk.RegistrationPreprocess(
        shape=shape,
        eqhist=ropt[&#39;preprocess&#39;][&#39;equalize_histogram&#39;],
        unsharp=ropt[&#39;preprocess&#39;][&#39;unsharp&#39;],
        edge=ropt[&#39;preprocess&#39;][&#39;edge&#39;])

    return registrator, prep

  def _register(self, file, registrator: rsitk.SITKRegistrator,
                prep: rsitk.RegistrationPreprocess):
    ir = IIO.read(self._fm.change_dir(DIR.IR, file))
    vis = IIO.read(self._fm.change_dir(DIR.VIS, file))

    if registrator is None:
      registrator, prep = self._init_registrator(shape=ir.shape)

    logger.debug(&#39;Registering &#34;{}&#34;&#39;, file.stem)
    fri, mri = registrator.prep_and_register(fixed_image=ir,
                                             moving_image=vis,
                                             preprocess=prep)
    rgst_color_img = mri.registered_orig_image()

    # 정합한 실화상
    path = self._fm.change_dir(DIR.RGST, file)
    IIO.save(path=path, array=tools.uint8_image(rgst_color_img))

    # 비교 영상
    compare_path = path.with_name(f&#39;{path.stem}{FN.RGST_AUTO}{path.suffix}&#39;)
    compare_fig, _ = tools.prep_compare_fig(
        images=(fri.prep_image(), mri.registered_prep_image()),
        titles=(&#39;열화상&#39;, &#39;실화상&#39;, &#39;비교 (Checkerboard)&#39;, &#39;비교 (Difference)&#39;))
    compare_fig.savefig(compare_path.joinpath(), dpi=200)
    plt.close(compare_fig)

    return mri.matrix

  def register(self):
    self.extract()
    self._fm.subdir(DIR.RGST, mkdir=True)

    files = self._fm.raw_files()
    registrator, prep, matrices = None, None, {}
    for file in utils.track(sequence=files, description=&#39;Registering...&#39;):
      if registrator is None:
        ir = IIO.read(self._fm.change_dir(DIR.IR, file))
        registrator, prep = self._init_registrator(shape=ir.shape)

      matrix = self._register(file=file, registrator=registrator, prep=prep)
      matrices[file.stem] = matrix

    np.savez(self._fm.rgst_matrix_path(), **matrices)
    logger.success(&#39;열화상-실화상 정합 완료&#39;)

  def register_generator(self):
    self._fm.subdir(DIR.RGST, mkdir=True)

    files = self._fm.raw_files()
    registrator, prep, matrices = None, None, {}
    for r, file in utils.ptrack(sequence=files, description=&#39;Registering...&#39;):
      if registrator is None:
        ir = IIO.read(self._fm.change_dir(DIR.IR, file))
        registrator, prep = self._init_registrator(shape=ir.shape)

      try:
        matrix = self._register(file=file, registrator=registrator, prep=prep)
      except FileNotFoundError as e:
        msg = f&#39;&#34;{e}&#34;를 찾을 수 없습니다. 열화상을 먼저 추출하세요.&#39;
        raise FileNotFoundError(msg) from e

      matrices[file.stem] = matrix

      yield r

    np.savez(self._fm.rgst_matrix_path(), **matrices)
    logger.success(&#39;열화상-실화상 정합 완료&#39;)
    yield 1.0

  def _init_segment_model(self):
    # pylint: disable=import-outside-toplevel
    from pano.segmentation import deeplab

    try:
      files = self._fm.files(DIR.RGST)
    except FileNotFoundError as e:
      path = Path(e.args[0]).relative_to(self._wd)
      msg = f&#39;&#34;{path}&#34;를 찾을 수 없습니다. 열화상-실화상 정합을 먼저 시행해주세요.&#39;
      raise FileNotFoundError(msg) from e

    try:
      model_path = self._fm.segment_model_path()
    except FileNotFoundError as e:
      raise FileNotFoundError(&#39;부위 인식 모델 파일을 불러올 수 없습니다.&#39;) from e

    deeplab.tf_gpu_memory_config()
    model = deeplab.DeepLabModel(model_path.as_posix())

    return files, model

  def _segment(self, model, file):
    image = IIO.read(file)
    seg_map, _, fig = model.predict_and_visualize(image)

    path = self._fm.change_dir(DIR.SEG, file)
    IIO.save(path=path, array=tools.SegMask.index_to_vis(seg_map))

    fig_path = path.with_name(f&#39;{path.stem}{FN.SEG_FIG}{FN.LS}&#39;)
    fig.savefig(fig_path)
    plt.close(fig)

  def segment(self):
    files, model = self._init_segment_model()

    self._fm.subdir(DIR.SEG, mkdir=True)
    for file in utils.track(files, description=&#39;Segmenting...&#39;):
      self._segment(model, file)

    logger.success(&#39;외피 부위 인식 완료&#39;)

  def segment_generator(self):
    files, model = self._init_segment_model()

    self._fm.subdir(DIR.SEG, mkdir=True)
    for r, file in utils.ptrack(files, description=&#39;Segmenting...&#39;):
      self._segment(model, file)
      yield r

    logger.success(&#39;외피 부위 인식 완료&#39;)
    yield 1.0

  def _init_stitcher(self) -&gt; stitch.Stitcher:
    sopt: DictConfig = self._config[&#39;panorama&#39;][&#39;stitch&#39;]

    stitcher = stitch.Stitcher(mode=sopt[&#39;perspective&#39;],
                               compose_scale=sopt[&#39;compose_scale&#39;],
                               work_scale=sopt[&#39;work_scale&#39;],
                               warp_threshold=sopt[&#39;warp_threshold&#39;])
    stitcher.warper_type = sopt[&#39;warp&#39;]

    logger.debug(&#39;Stitcher 초기화&#39;)

    return stitcher

  def _stitch(
      self,
      stitcher: stitch.Stitcher,
      images: List[np.ndarray],
      names: List[str],
      spectrum: str,
  ) -&gt; stitch.Panorama:
    popt: DictConfig = self._config[&#39;panorama&#39;][&#39;preprocess&#39;][spectrum]

    # 전처리 정의
    prep = stitch.PanoramaPreprocess(is_numeric=(images[0].ndim == 2),
                                     mask_threshold=popt[&#39;masking_threshold&#39;],
                                     contrast=popt[&#39;contrast&#39;],
                                     denoise=popt[&#39;denoise&#39;])
    if &#39;bilateral_args&#39; in popt:
      prep.set_bilateral_args(**popt[&#39;bilateral_args&#39;])
    if &#39;gaussian_args&#39; in popt:
      prep.set_gaussian_args(**popt[&#39;gaussian_args&#39;])

    # 대상 영상
    stitching_images = stitch.StitchingImages(arrays=images)
    stitching_images.set_preprocess(prep)
    logger.trace(&#39;Stitch 대상 영상 &amp; 전처리 설정&#39;)

    with utils.console.status(&#39;Stitching...&#39;):
      res = stitcher.stitch(images=stitching_images,
                            masks=None,
                            names=names,
                            crop=self._config[&#39;panorama&#39;][&#39;stitch&#39;][&#39;crop&#39;])

    return res

  def _save_panorama(self,
                     spectrum: SP,
                     panorama: stitch.Panorama,
                     save_mask=True,
                     save_meta=True):
    self._fm.subdir(DIR.PANO, mkdir=True)

    if max(panorama.panorama.shape[:2]) &gt; self._size_limit:
      panorama.panorama = self.limit_size(panorama.panorama)
      panorama.mask = self.limit_size(panorama.mask)

    meta = None
    if save_meta:
      meta = {
          &#39;panorama&#39;: {
              &#39;including&#39;: panorama.included(),
              &#39;not_including&#39;: panorama.not_included(),
              &#39;graph&#39;: panorama.graph_list()
          }
      }

    with utils.console.status(&#39;Saving...&#39;):
      path = self._fm.panorama_path(DIR.PANO, spectrum)
      if spectrum is SP.IR:
        # 적외선 수치, meta 정보 저장
        IIO.save_with_meta(path=path,
                           array=panorama.panorama.astype(np.float16),
                           exts=[FN.NPY],
                           meta=meta)

        # 적외선 colormap 영상 저장
        color_panorama = apply_colormap(panorama.panorama, self._cmap)
        IIO.save(path=self._fm.color_path(path), array=color_panorama)
      else:
        # 실화상 저장
        IIO.save_with_meta(path=path,
                           array=np.round(panorama.panorama).astype(np.uint8),
                           exts=[FN.LS],
                           meta=meta)

      if save_mask:
        # 마스크 저장
        IIO.save(path=self._fm.panorama_path(DIR.PANO, SP.MASK),
                 array=tools.uint8_image(panorama.mask))

  def _stitch_others(self, stitcher: stitch.Stitcher, panorama: stitch.Panorama,
                     spectrum: SP):
    try:
      files = self._fm.files(self._SP_DIR[spectrum.value])
    except FileNotFoundError as e:
      msg = &#39;&#34;{}&#34; 파일을 찾을 수 없습니다. {} 파노라마를 생성할 수 없습니다.&#39;.format(
          Path(e.args[0]).relative_to(self._wd), self._SP_KOR[spectrum.value])
      raise FileNotFoundError(msg) from e

    files = [files[x] for x in panorama.indices]
    images = [IIO.read(x) for x in files]
    cameras = [panorama.cameras[x] for x in panorama.indices]

    pano, _, _ = stitcher.warp_and_blend(
        images=stitch.StitchingImages(arrays=images),
        cameras=cameras,
        masks=None,
        names=[x.name for x in files])

    if panorama.crop_range:
      pano = panorama.crop_range.crop(pano, strict=False)

    if spectrum is SP.IR:
      pano = pano[:, :, 0]
      pano = pano.astype(np.float16)
    else:
      pano = np.round(pano).astype(np.uint8)

    if spectrum is SP.SEG:
      IIO.save(path=self._fm.panorama_path(DIR.PANO, spectrum),
               array=self.limit_size(pano))
    else:
      panorama.panorama = pano
      self._save_panorama(spectrum=spectrum,
                          panorama=panorama,
                          save_mask=False,
                          save_meta=False)

  def panorama(self):
    spectrum = self._config[&#39;panorama&#39;][&#39;target&#39;].upper()
    if spectrum not in (&#39;IR&#39;, &#39;VIS&#39;):
      raise ValueError(spectrum)

    sopt = self._config[&#39;panorama&#39;][&#39;stitch&#39;]
    stitcher = self._init_stitcher()

    # Raw 파일 추출
    self.extract()

    # 지정한 spectrum 파노라마
    files = self._fm.files(self._SP_DIR[spectrum])
    images = [IIO.read(x) for x in files]

    # 파노라마 생성
    stitcher.set_blend_type(sopt[&#39;blend&#39;][spectrum])
    pano = self._stitch(stitcher=stitcher,
                        images=images,
                        names=[x.stem for x in files],
                        spectrum=spectrum)

    # 저장
    self._save_panorama(spectrum=SP[spectrum], panorama=pano)

    # segmention mask 저장
    stitcher.set_blend_type(False)
    self._stitch_others(stitcher=stitcher, panorama=pano, spectrum=SP.SEG)

    # 나머지 영상의 파노라마 생성/저장
    sp2 = &#39;VIS&#39; if spectrum == &#39;IR&#39; else &#39;IR&#39;
    stitcher.set_blend_type(sopt[&#39;blend&#39;][sp2])
    self._stitch_others(stitcher=stitcher, panorama=pano, spectrum=SP[sp2])

    logger.success(&#39;파노라마 생성 완료&#39;)

  def _init_perspective_correction(self):
    options = self._config[&#39;distort_correction&#39;]

    canny_options = persp.CannyOptions(**options[&#39;canny&#39;])
    hough_options = persp.HoughOptions(**options[&#39;hough&#39;])
    correction_opts = persp.CorrectionOptions(**options[&#39;correction&#39;])

    pc = persp.PerspectiveCorrection(canny_options=canny_options,
                                     hough_options=hough_options,
                                     correction_options=correction_opts)
    return pc

  def _correct_others(self, correction: persp.Correction, spectrum: SP):
    try:
      path = self._fm.panorama_path(DIR.PANO, spectrum, error=True)
    except FileNotFoundError as e:
      raise FileNotFoundError(&#39;{} 파노라마가 존재하지 않습니다.&#39;.format(
          self._SP_KOR[spectrum.value])) from e

    pano = IIO.read(path=path)
    pano_corrected = correction.correct(pano)[0].astype(np.uint8)
    pano_limited = self.limit_size(pano_corrected)

    IIO.save(path=self._fm.panorama_path(DIR.COR, spectrum), array=pano_limited)
    logger.debug(&#39;{} 파노라마 왜곡 보정 저장&#39;, self._SP_KOR[spectrum.value])

  def correct(self):
    pc = self._init_perspective_correction()

    try:
      ir_path = self._fm.panorama_path(DIR.PANO, SP.IR, error=True)
    except FileNotFoundError as e:
      raise FileNotFoundError(&#39;생성된 파노라마 파일이 없습니다.&#39;) from e

    logger.trace(&#39;Init perspective correction&#39;)

    # 적외선 파노라마
    pano = IIO.read(ir_path).astype(np.float32)
    if self._config[&#39;distort_correction&#39;][&#39;apply_mask&#39;]:
      mask = IIO.read(self._fm.panorama_path(DIR.PANO, SP.MASK)).astype(bool)
    else:
      mask = None

    # 왜곡 보정
    try:
      crct = pc.perspective_correct(image=pano, mask=mask)
    except persp.NotEnoughEdgelets as e:
      raise persp.NotEnoughEdgelets(
          &#39;시점 왜곡을 추정할 edge의 개수가 부족합니다. &#39;
          &#39;Edge 추출 옵션을 변경하거나 높은 해상도의 파노라마를 사용하세요.&#39;) from e

    # plot 저장
    self._fm.subdir(DIR.COR, mkdir=True)
    fig, _ = crct.process_plot(image=pano)
    fig.savefig(self._fm.correction_plot_path(), dpi=300)
    plt.close(fig)

    if not crct.success():
      raise ValueError(&#39;IR 파노라마 왜곡 보정 중 오류 발생. 저장된 plot을 참고해주세요.&#39;)

    logger.debug(&#39;IR 파노라마 왜곡 보정 완료&#39;)

    # 적외선 파노라마 저장
    cpano, cmask = crct.correct(pano, mask)
    cpano = self.limit_size(cpano)
    path = self._fm.panorama_path(DIR.COR, SP.IR)
    IIO.save_with_meta(path=path,
                       array=cpano.astype(np.float16),
                       exts=[FN.NPY, FN.LL],
                       dtype=&#39;uint16&#39;)

    # colormap 적용 버전 저장
    IIO.save(path=self._fm.color_path(path),
             array=apply_colormap(cpano, self._cmap))
    logger.debug(&#39;IR 파노라마 보정 파일 저장&#39;)

    # mask 저장
    if cmask is not None:
      cmask = self.limit_size(cmask)
      IIO.save(path=self._fm.panorama_path(DIR.COR, SP.MASK),
               array=tools.uint8_image(cmask))

    # 실화상, 부위인식 파노라마 보정
    self._correct_others(correction=crct, spectrum=SP.VIS)
    self._correct_others(correction=crct, spectrum=SP.SEG)

    logger.success(&#39;파노라마 왜곡 보정 완료&#39;)

  def run(self):
    logger.info(&#39;Start extracting&#39;)
    self.extract()

    logger.info(&#39;Start registering&#39;)
    self.register()

    logger.info(&#39;Start segmenting&#39;)
    self.segment()

    logger.info(&#39;Start panorama stitching&#39;)
    self.panorama()

    logger.info(&#39;Start distortion correction&#39;)
    self.correct()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pano.interface.pano_project.ThermalPanorama"><code class="flex name class">
<span>class <span class="ident">ThermalPanorama</span></span>
<span>(</span><span>directory: Union[str, pathlib.Path], default_config=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ThermalPanorama:
  _SP_DIR = {
      SP.IR.value: DIR.IR,
      SP.VIS.value: DIR.RGST,
      SP.SEG.value: DIR.SEG,
  }
  _SP_KOR = {
      SP.IR.value: &#39;열화상&#39;,
      SP.VIS.value: &#39;실화상&#39;,
      SP.SEG.value: &#39;부위 인식&#39;,
  }

  def __init__(self, directory: Union[str, Path], default_config=False) -&gt; None:
    # working directory
    wd = Path(directory).resolve()
    if not wd.exists():
      raise FileNotFoundError(wd)

    self._wd = wd
    self._config = set_config(directory=wd, default=default_config)
    self._fm = ThermalPanoramaFileManager(directory=wd)

    # 제조사, Raw 파일 패턴
    self._manufacturer = self._check_manufacturer()
    self._fm.raw_pattern = self._config[&#39;file&#39;][self._manufacturer][&#39;IR&#39;]
    if self._manufacturer != &#39;FLIR&#39;:
      self._flir_ext = None
    else:
      self._flir_ext = flir.FlirExtractor()
    logger.info(&#39;Manufacturer: {}&#39;, self._manufacturer)

    # 카메라 기종
    self._camera = self._check_camera_model()
    logger.info(&#39;Camera: {}&#39;, self._camera)

    # 컬러맵
    self._cmap = get_thermal_colormap(
        name=self._config[&#39;color&#39;].get(&#39;colormap&#39;, &#39;iron&#39;))

  def _check_manufacturer(self) -&gt; str:
    fopt: DictConfig = self._config[&#39;file&#39;]
    flir_files = self._fm.glob(d=DIR.RAW, pattern=fopt[&#39;FLIR&#39;][&#39;IR&#39;])
    testo_ir_files = self._fm.glob(d=DIR.RAW, pattern=fopt[&#39;testo&#39;][&#39;IR&#39;])
    testo_vis_files = self._fm.glob(d=DIR.RAW, pattern=fopt[&#39;testo&#39;][&#39;VIS&#39;])

    if testo_ir_files and testo_vis_files:
      manufacturer = &#39;testo&#39;
    elif flir_files:
      manufacturer = &#39;FLIR&#39;
    else:
      raise ValueError(&#39;지원하지 않는 Raw 파일 형식입니다.&#39;)

    return manufacturer

  def _check_camera_model(self) -&gt; Optional[str]:
    tags = [&#39;Model&#39;, &#39;CameraModel&#39;]
    raw_files = self._fm.raw_files()

    def _get_model(exif: dict):
      # iterable 중 조건을 만족하는 첫 element
      tag = next((x for x in exif.keys() if x in tags), None)
      if tag is None:
        return None

      return exif[tag]

    exifs = exif.get_exif(files=[x.as_posix() for x in raw_files], tags=tags)
    models = [_get_model(x) for x in exifs]
    models = [x for x in models if x is not None]

    if not models:
      logger.debug(&#39;Exif로부터 카메라 기종 추정 불가&#39;)
      return None

    if any(models[0] != x for x in models[1:]):
      logger.warning(&#39;다수의 카메라로 촬영된 Raw 파일을 입력했습니다 ({}). &#39;
                     &#39;카메라 기종을 추정할 수 없습니다.&#39;, set(models))
      return None

    return models[0]

  def _extract_flir_image(self, path: Path):
    assert self._flir_ext is not None
    ir, vis = self._flir_ext.extract_data(path)
    meta = {&#39;Exif&#39;: exif.get_exif(files=path.as_posix())[0]}

    if self._config[&#39;file&#39;][&#39;force_horizontal&#39;] and (ir.shape[0] &gt; ir.shape[1]):
      # 수직 영상을 수평으로 만들기 위해 90도 회전
      if self._config[&#39;file&#39;][&#39;force_horizontal&#39;] == &#39;CCW&#39;:
        k = 1
      elif self._config[&#39;file&#39;][&#39;force_horizontal&#39;] == &#39;CW&#39;:
        k = 3
      else:
        raise ValueError(&#39;&#34;force_horizontal must be one of {&#34;CW&#34;, &#34;CCW&#34;}&#39;)

      logger.debug(&#39;Rotate &#34;{}&#34; (k={})&#39;, path.name, k)
      ir = np.rot90(ir, k=k, axes=(0, 1))
      vis = np.rot90(vis, k=k, axes=(0, 1))

    # FLIR One로 찍은 사진은 수직으로 촬영해도 orientation 번호가
    # `1` (`Horizontal (normal)`)로 표시되어서 아래 정보가 쓸모가 없음...

    # tag = exif.get_exif_tags(path.as_posix(), &#39;-Orientation&#39;, &#39;-n&#39;)
    # orientation = tag[&#39;Orientation&#39;]

    return ir, vis, meta

  def _extract_testo_image(self, path: Path):
    vis_suffix = self._config[&#39;file&#39;][&#39;testo&#39;][&#39;VIS&#39;].replace(&#39;*&#39;, &#39;&#39;)
    vis_path = path.with_name(path.stem + vis_suffix)

    ir = IIO.read(path=path)
    vis = IIO.read(path=vis_path)

    return ir, vis

  def _save_extracted_image(self,
                            fname: str,
                            ir: np.ndarray,
                            vis: np.ndarray,
                            meta: Optional[dict] = None):
    &#34;&#34;&#34;추출한 열/실화상을 각 폴더에 저장&#34;&#34;&#34;
    ir_path = self._fm.change_dir(DIR.IR, file=fname)
    vis_path = self._fm.change_dir(DIR.VIS, file=fname)

    IIO.save_with_meta(path=ir_path, array=ir, exts=[FN.NPY], meta=meta)

    if self._config[&#39;color&#39;][&#39;extract_color_image&#39;]:
      color_image = apply_colormap(ir, self._cmap)
      IIO.save(path=self._fm.color_path(ir_path), array=color_image)

    IIO.save(path=vis_path, array=vis)

  def _extract_raw_file(self, file: Path):
    &#34;&#34;&#34;
    Raw 열화상, 실화상 파일 추출.

    Parameters
    ----------
    file : Path
        Raw 파일 경로
    &#34;&#34;&#34;
    if not file.exists():
      raise FileNotFoundError(file)

    ir_path = self._fm.change_dir(DIR.IR, file)
    vis_path = self._fm.change_dir(DIR.VIS, file)
    if ir_path.exists() and vis_path.exists():
      return

    logger.debug(&#39;Extracting &#34;{}&#34;&#39;, file.name)

    if self._manufacturer == &#39;FLIR&#39;:
      ir, vis, meta = self._extract_flir_image(path=file)
    elif self._manufacturer == &#39;testo&#39;:
      ir, vis = self._extract_testo_image(path=file)
      meta = None
    else:
      raise ValueError

    assert ir is not None
    self._save_extracted_image(fname=file.stem, ir=ir, vis=vis, meta=meta)

  def extract(self):
    try:
      self._fm.files(DIR.IR)
      self._fm.files(DIR.VIS)
    except FileNotFoundError:
      self._fm.subdir(DIR.IR, mkdir=True)
      self._fm.subdir(DIR.VIS, mkdir=True)

      files = self._fm.raw_files()
      for file in utils.track(files, description=&#39;Extracting images...&#39;):
        self._extract_raw_file(file=file)

  def extract_generator(self):
    try:
      self._fm.files(DIR.IR)
      self._fm.files(DIR.VIS)
    except FileNotFoundError:
      self._fm.subdir(DIR.IR, mkdir=True)
      self._fm.subdir(DIR.VIS, mkdir=True)

      files = self._fm.raw_files()
      for r, file in utils.ptrack(files, description=&#39;Extracting images...&#39;):
        self._extract_raw_file(file=file)
        yield r

  @property
  def _size_limit(self):
    return self._config[&#39;file&#39;][&#39;size_limit&#39;]

  def limit_size(self, image: np.ndarray) -&gt; np.ndarray:
    return tools.limit_image_size(image=image, limit=self._size_limit)

  def _init_registrator(self, shape):
    ropt: DictConfig = self._config[&#39;registration&#39;]

    if self._camera in self._config[&#39;camera&#39;]:
      camera = self._camera
    else:
      camera = &#39;default&#39;

    copt: DictConfig = self._config[&#39;camera&#39;][camera]
    logger.debug(&#39;Regestering preset: {}&#39;, camera)

    trsf = rsitk.Transformation[ropt[&#39;transformation&#39;]]
    metric = rsitk.Metric[ropt[&#39;metric&#39;]]
    optimizer = ropt[&#39;optimizer&#39;]

    registrator = rsitk.SITKRegistrator(transformation=trsf,
                                        metric=metric,
                                        optimizer=optimizer,
                                        bins=ropt[&#39;bins&#39;])
    aov = [
        np.deg2rad(copt[x]) if copt[x] else None for x in [&#39;IR_AOV&#39;, &#39;VIS_AOV&#39;]
    ]
    registrator.set_initial_params(scale=copt[&#39;scale&#39;],
                                   fixed_alpha=aov[0],
                                   moving_alpha=aov[1],
                                   translation=copt[&#39;translation&#39;])
    prep = rsitk.RegistrationPreprocess(
        shape=shape,
        eqhist=ropt[&#39;preprocess&#39;][&#39;equalize_histogram&#39;],
        unsharp=ropt[&#39;preprocess&#39;][&#39;unsharp&#39;],
        edge=ropt[&#39;preprocess&#39;][&#39;edge&#39;])

    return registrator, prep

  def _register(self, file, registrator: rsitk.SITKRegistrator,
                prep: rsitk.RegistrationPreprocess):
    ir = IIO.read(self._fm.change_dir(DIR.IR, file))
    vis = IIO.read(self._fm.change_dir(DIR.VIS, file))

    if registrator is None:
      registrator, prep = self._init_registrator(shape=ir.shape)

    logger.debug(&#39;Registering &#34;{}&#34;&#39;, file.stem)
    fri, mri = registrator.prep_and_register(fixed_image=ir,
                                             moving_image=vis,
                                             preprocess=prep)
    rgst_color_img = mri.registered_orig_image()

    # 정합한 실화상
    path = self._fm.change_dir(DIR.RGST, file)
    IIO.save(path=path, array=tools.uint8_image(rgst_color_img))

    # 비교 영상
    compare_path = path.with_name(f&#39;{path.stem}{FN.RGST_AUTO}{path.suffix}&#39;)
    compare_fig, _ = tools.prep_compare_fig(
        images=(fri.prep_image(), mri.registered_prep_image()),
        titles=(&#39;열화상&#39;, &#39;실화상&#39;, &#39;비교 (Checkerboard)&#39;, &#39;비교 (Difference)&#39;))
    compare_fig.savefig(compare_path.joinpath(), dpi=200)
    plt.close(compare_fig)

    return mri.matrix

  def register(self):
    self.extract()
    self._fm.subdir(DIR.RGST, mkdir=True)

    files = self._fm.raw_files()
    registrator, prep, matrices = None, None, {}
    for file in utils.track(sequence=files, description=&#39;Registering...&#39;):
      if registrator is None:
        ir = IIO.read(self._fm.change_dir(DIR.IR, file))
        registrator, prep = self._init_registrator(shape=ir.shape)

      matrix = self._register(file=file, registrator=registrator, prep=prep)
      matrices[file.stem] = matrix

    np.savez(self._fm.rgst_matrix_path(), **matrices)
    logger.success(&#39;열화상-실화상 정합 완료&#39;)

  def register_generator(self):
    self._fm.subdir(DIR.RGST, mkdir=True)

    files = self._fm.raw_files()
    registrator, prep, matrices = None, None, {}
    for r, file in utils.ptrack(sequence=files, description=&#39;Registering...&#39;):
      if registrator is None:
        ir = IIO.read(self._fm.change_dir(DIR.IR, file))
        registrator, prep = self._init_registrator(shape=ir.shape)

      try:
        matrix = self._register(file=file, registrator=registrator, prep=prep)
      except FileNotFoundError as e:
        msg = f&#39;&#34;{e}&#34;를 찾을 수 없습니다. 열화상을 먼저 추출하세요.&#39;
        raise FileNotFoundError(msg) from e

      matrices[file.stem] = matrix

      yield r

    np.savez(self._fm.rgst_matrix_path(), **matrices)
    logger.success(&#39;열화상-실화상 정합 완료&#39;)
    yield 1.0

  def _init_segment_model(self):
    # pylint: disable=import-outside-toplevel
    from pano.segmentation import deeplab

    try:
      files = self._fm.files(DIR.RGST)
    except FileNotFoundError as e:
      path = Path(e.args[0]).relative_to(self._wd)
      msg = f&#39;&#34;{path}&#34;를 찾을 수 없습니다. 열화상-실화상 정합을 먼저 시행해주세요.&#39;
      raise FileNotFoundError(msg) from e

    try:
      model_path = self._fm.segment_model_path()
    except FileNotFoundError as e:
      raise FileNotFoundError(&#39;부위 인식 모델 파일을 불러올 수 없습니다.&#39;) from e

    deeplab.tf_gpu_memory_config()
    model = deeplab.DeepLabModel(model_path.as_posix())

    return files, model

  def _segment(self, model, file):
    image = IIO.read(file)
    seg_map, _, fig = model.predict_and_visualize(image)

    path = self._fm.change_dir(DIR.SEG, file)
    IIO.save(path=path, array=tools.SegMask.index_to_vis(seg_map))

    fig_path = path.with_name(f&#39;{path.stem}{FN.SEG_FIG}{FN.LS}&#39;)
    fig.savefig(fig_path)
    plt.close(fig)

  def segment(self):
    files, model = self._init_segment_model()

    self._fm.subdir(DIR.SEG, mkdir=True)
    for file in utils.track(files, description=&#39;Segmenting...&#39;):
      self._segment(model, file)

    logger.success(&#39;외피 부위 인식 완료&#39;)

  def segment_generator(self):
    files, model = self._init_segment_model()

    self._fm.subdir(DIR.SEG, mkdir=True)
    for r, file in utils.ptrack(files, description=&#39;Segmenting...&#39;):
      self._segment(model, file)
      yield r

    logger.success(&#39;외피 부위 인식 완료&#39;)
    yield 1.0

  def _init_stitcher(self) -&gt; stitch.Stitcher:
    sopt: DictConfig = self._config[&#39;panorama&#39;][&#39;stitch&#39;]

    stitcher = stitch.Stitcher(mode=sopt[&#39;perspective&#39;],
                               compose_scale=sopt[&#39;compose_scale&#39;],
                               work_scale=sopt[&#39;work_scale&#39;],
                               warp_threshold=sopt[&#39;warp_threshold&#39;])
    stitcher.warper_type = sopt[&#39;warp&#39;]

    logger.debug(&#39;Stitcher 초기화&#39;)

    return stitcher

  def _stitch(
      self,
      stitcher: stitch.Stitcher,
      images: List[np.ndarray],
      names: List[str],
      spectrum: str,
  ) -&gt; stitch.Panorama:
    popt: DictConfig = self._config[&#39;panorama&#39;][&#39;preprocess&#39;][spectrum]

    # 전처리 정의
    prep = stitch.PanoramaPreprocess(is_numeric=(images[0].ndim == 2),
                                     mask_threshold=popt[&#39;masking_threshold&#39;],
                                     contrast=popt[&#39;contrast&#39;],
                                     denoise=popt[&#39;denoise&#39;])
    if &#39;bilateral_args&#39; in popt:
      prep.set_bilateral_args(**popt[&#39;bilateral_args&#39;])
    if &#39;gaussian_args&#39; in popt:
      prep.set_gaussian_args(**popt[&#39;gaussian_args&#39;])

    # 대상 영상
    stitching_images = stitch.StitchingImages(arrays=images)
    stitching_images.set_preprocess(prep)
    logger.trace(&#39;Stitch 대상 영상 &amp; 전처리 설정&#39;)

    with utils.console.status(&#39;Stitching...&#39;):
      res = stitcher.stitch(images=stitching_images,
                            masks=None,
                            names=names,
                            crop=self._config[&#39;panorama&#39;][&#39;stitch&#39;][&#39;crop&#39;])

    return res

  def _save_panorama(self,
                     spectrum: SP,
                     panorama: stitch.Panorama,
                     save_mask=True,
                     save_meta=True):
    self._fm.subdir(DIR.PANO, mkdir=True)

    if max(panorama.panorama.shape[:2]) &gt; self._size_limit:
      panorama.panorama = self.limit_size(panorama.panorama)
      panorama.mask = self.limit_size(panorama.mask)

    meta = None
    if save_meta:
      meta = {
          &#39;panorama&#39;: {
              &#39;including&#39;: panorama.included(),
              &#39;not_including&#39;: panorama.not_included(),
              &#39;graph&#39;: panorama.graph_list()
          }
      }

    with utils.console.status(&#39;Saving...&#39;):
      path = self._fm.panorama_path(DIR.PANO, spectrum)
      if spectrum is SP.IR:
        # 적외선 수치, meta 정보 저장
        IIO.save_with_meta(path=path,
                           array=panorama.panorama.astype(np.float16),
                           exts=[FN.NPY],
                           meta=meta)

        # 적외선 colormap 영상 저장
        color_panorama = apply_colormap(panorama.panorama, self._cmap)
        IIO.save(path=self._fm.color_path(path), array=color_panorama)
      else:
        # 실화상 저장
        IIO.save_with_meta(path=path,
                           array=np.round(panorama.panorama).astype(np.uint8),
                           exts=[FN.LS],
                           meta=meta)

      if save_mask:
        # 마스크 저장
        IIO.save(path=self._fm.panorama_path(DIR.PANO, SP.MASK),
                 array=tools.uint8_image(panorama.mask))

  def _stitch_others(self, stitcher: stitch.Stitcher, panorama: stitch.Panorama,
                     spectrum: SP):
    try:
      files = self._fm.files(self._SP_DIR[spectrum.value])
    except FileNotFoundError as e:
      msg = &#39;&#34;{}&#34; 파일을 찾을 수 없습니다. {} 파노라마를 생성할 수 없습니다.&#39;.format(
          Path(e.args[0]).relative_to(self._wd), self._SP_KOR[spectrum.value])
      raise FileNotFoundError(msg) from e

    files = [files[x] for x in panorama.indices]
    images = [IIO.read(x) for x in files]
    cameras = [panorama.cameras[x] for x in panorama.indices]

    pano, _, _ = stitcher.warp_and_blend(
        images=stitch.StitchingImages(arrays=images),
        cameras=cameras,
        masks=None,
        names=[x.name for x in files])

    if panorama.crop_range:
      pano = panorama.crop_range.crop(pano, strict=False)

    if spectrum is SP.IR:
      pano = pano[:, :, 0]
      pano = pano.astype(np.float16)
    else:
      pano = np.round(pano).astype(np.uint8)

    if spectrum is SP.SEG:
      IIO.save(path=self._fm.panorama_path(DIR.PANO, spectrum),
               array=self.limit_size(pano))
    else:
      panorama.panorama = pano
      self._save_panorama(spectrum=spectrum,
                          panorama=panorama,
                          save_mask=False,
                          save_meta=False)

  def panorama(self):
    spectrum = self._config[&#39;panorama&#39;][&#39;target&#39;].upper()
    if spectrum not in (&#39;IR&#39;, &#39;VIS&#39;):
      raise ValueError(spectrum)

    sopt = self._config[&#39;panorama&#39;][&#39;stitch&#39;]
    stitcher = self._init_stitcher()

    # Raw 파일 추출
    self.extract()

    # 지정한 spectrum 파노라마
    files = self._fm.files(self._SP_DIR[spectrum])
    images = [IIO.read(x) for x in files]

    # 파노라마 생성
    stitcher.set_blend_type(sopt[&#39;blend&#39;][spectrum])
    pano = self._stitch(stitcher=stitcher,
                        images=images,
                        names=[x.stem for x in files],
                        spectrum=spectrum)

    # 저장
    self._save_panorama(spectrum=SP[spectrum], panorama=pano)

    # segmention mask 저장
    stitcher.set_blend_type(False)
    self._stitch_others(stitcher=stitcher, panorama=pano, spectrum=SP.SEG)

    # 나머지 영상의 파노라마 생성/저장
    sp2 = &#39;VIS&#39; if spectrum == &#39;IR&#39; else &#39;IR&#39;
    stitcher.set_blend_type(sopt[&#39;blend&#39;][sp2])
    self._stitch_others(stitcher=stitcher, panorama=pano, spectrum=SP[sp2])

    logger.success(&#39;파노라마 생성 완료&#39;)

  def _init_perspective_correction(self):
    options = self._config[&#39;distort_correction&#39;]

    canny_options = persp.CannyOptions(**options[&#39;canny&#39;])
    hough_options = persp.HoughOptions(**options[&#39;hough&#39;])
    correction_opts = persp.CorrectionOptions(**options[&#39;correction&#39;])

    pc = persp.PerspectiveCorrection(canny_options=canny_options,
                                     hough_options=hough_options,
                                     correction_options=correction_opts)
    return pc

  def _correct_others(self, correction: persp.Correction, spectrum: SP):
    try:
      path = self._fm.panorama_path(DIR.PANO, spectrum, error=True)
    except FileNotFoundError as e:
      raise FileNotFoundError(&#39;{} 파노라마가 존재하지 않습니다.&#39;.format(
          self._SP_KOR[spectrum.value])) from e

    pano = IIO.read(path=path)
    pano_corrected = correction.correct(pano)[0].astype(np.uint8)
    pano_limited = self.limit_size(pano_corrected)

    IIO.save(path=self._fm.panorama_path(DIR.COR, spectrum), array=pano_limited)
    logger.debug(&#39;{} 파노라마 왜곡 보정 저장&#39;, self._SP_KOR[spectrum.value])

  def correct(self):
    pc = self._init_perspective_correction()

    try:
      ir_path = self._fm.panorama_path(DIR.PANO, SP.IR, error=True)
    except FileNotFoundError as e:
      raise FileNotFoundError(&#39;생성된 파노라마 파일이 없습니다.&#39;) from e

    logger.trace(&#39;Init perspective correction&#39;)

    # 적외선 파노라마
    pano = IIO.read(ir_path).astype(np.float32)
    if self._config[&#39;distort_correction&#39;][&#39;apply_mask&#39;]:
      mask = IIO.read(self._fm.panorama_path(DIR.PANO, SP.MASK)).astype(bool)
    else:
      mask = None

    # 왜곡 보정
    try:
      crct = pc.perspective_correct(image=pano, mask=mask)
    except persp.NotEnoughEdgelets as e:
      raise persp.NotEnoughEdgelets(
          &#39;시점 왜곡을 추정할 edge의 개수가 부족합니다. &#39;
          &#39;Edge 추출 옵션을 변경하거나 높은 해상도의 파노라마를 사용하세요.&#39;) from e

    # plot 저장
    self._fm.subdir(DIR.COR, mkdir=True)
    fig, _ = crct.process_plot(image=pano)
    fig.savefig(self._fm.correction_plot_path(), dpi=300)
    plt.close(fig)

    if not crct.success():
      raise ValueError(&#39;IR 파노라마 왜곡 보정 중 오류 발생. 저장된 plot을 참고해주세요.&#39;)

    logger.debug(&#39;IR 파노라마 왜곡 보정 완료&#39;)

    # 적외선 파노라마 저장
    cpano, cmask = crct.correct(pano, mask)
    cpano = self.limit_size(cpano)
    path = self._fm.panorama_path(DIR.COR, SP.IR)
    IIO.save_with_meta(path=path,
                       array=cpano.astype(np.float16),
                       exts=[FN.NPY, FN.LL],
                       dtype=&#39;uint16&#39;)

    # colormap 적용 버전 저장
    IIO.save(path=self._fm.color_path(path),
             array=apply_colormap(cpano, self._cmap))
    logger.debug(&#39;IR 파노라마 보정 파일 저장&#39;)

    # mask 저장
    if cmask is not None:
      cmask = self.limit_size(cmask)
      IIO.save(path=self._fm.panorama_path(DIR.COR, SP.MASK),
               array=tools.uint8_image(cmask))

    # 실화상, 부위인식 파노라마 보정
    self._correct_others(correction=crct, spectrum=SP.VIS)
    self._correct_others(correction=crct, spectrum=SP.SEG)

    logger.success(&#39;파노라마 왜곡 보정 완료&#39;)

  def run(self):
    logger.info(&#39;Start extracting&#39;)
    self.extract()

    logger.info(&#39;Start registering&#39;)
    self.register()

    logger.info(&#39;Start segmenting&#39;)
    self.segment()

    logger.info(&#39;Start panorama stitching&#39;)
    self.panorama()

    logger.info(&#39;Start distortion correction&#39;)
    self.correct()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pano.interface.pano_project.ThermalPanorama.correct"><code class="name flex">
<span>def <span class="ident">correct</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def correct(self):
  pc = self._init_perspective_correction()

  try:
    ir_path = self._fm.panorama_path(DIR.PANO, SP.IR, error=True)
  except FileNotFoundError as e:
    raise FileNotFoundError(&#39;생성된 파노라마 파일이 없습니다.&#39;) from e

  logger.trace(&#39;Init perspective correction&#39;)

  # 적외선 파노라마
  pano = IIO.read(ir_path).astype(np.float32)
  if self._config[&#39;distort_correction&#39;][&#39;apply_mask&#39;]:
    mask = IIO.read(self._fm.panorama_path(DIR.PANO, SP.MASK)).astype(bool)
  else:
    mask = None

  # 왜곡 보정
  try:
    crct = pc.perspective_correct(image=pano, mask=mask)
  except persp.NotEnoughEdgelets as e:
    raise persp.NotEnoughEdgelets(
        &#39;시점 왜곡을 추정할 edge의 개수가 부족합니다. &#39;
        &#39;Edge 추출 옵션을 변경하거나 높은 해상도의 파노라마를 사용하세요.&#39;) from e

  # plot 저장
  self._fm.subdir(DIR.COR, mkdir=True)
  fig, _ = crct.process_plot(image=pano)
  fig.savefig(self._fm.correction_plot_path(), dpi=300)
  plt.close(fig)

  if not crct.success():
    raise ValueError(&#39;IR 파노라마 왜곡 보정 중 오류 발생. 저장된 plot을 참고해주세요.&#39;)

  logger.debug(&#39;IR 파노라마 왜곡 보정 완료&#39;)

  # 적외선 파노라마 저장
  cpano, cmask = crct.correct(pano, mask)
  cpano = self.limit_size(cpano)
  path = self._fm.panorama_path(DIR.COR, SP.IR)
  IIO.save_with_meta(path=path,
                     array=cpano.astype(np.float16),
                     exts=[FN.NPY, FN.LL],
                     dtype=&#39;uint16&#39;)

  # colormap 적용 버전 저장
  IIO.save(path=self._fm.color_path(path),
           array=apply_colormap(cpano, self._cmap))
  logger.debug(&#39;IR 파노라마 보정 파일 저장&#39;)

  # mask 저장
  if cmask is not None:
    cmask = self.limit_size(cmask)
    IIO.save(path=self._fm.panorama_path(DIR.COR, SP.MASK),
             array=tools.uint8_image(cmask))

  # 실화상, 부위인식 파노라마 보정
  self._correct_others(correction=crct, spectrum=SP.VIS)
  self._correct_others(correction=crct, spectrum=SP.SEG)

  logger.success(&#39;파노라마 왜곡 보정 완료&#39;)</code></pre>
</details>
</dd>
<dt id="pano.interface.pano_project.ThermalPanorama.extract"><code class="name flex">
<span>def <span class="ident">extract</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract(self):
  try:
    self._fm.files(DIR.IR)
    self._fm.files(DIR.VIS)
  except FileNotFoundError:
    self._fm.subdir(DIR.IR, mkdir=True)
    self._fm.subdir(DIR.VIS, mkdir=True)

    files = self._fm.raw_files()
    for file in utils.track(files, description=&#39;Extracting images...&#39;):
      self._extract_raw_file(file=file)</code></pre>
</details>
</dd>
<dt id="pano.interface.pano_project.ThermalPanorama.extract_generator"><code class="name flex">
<span>def <span class="ident">extract_generator</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_generator(self):
  try:
    self._fm.files(DIR.IR)
    self._fm.files(DIR.VIS)
  except FileNotFoundError:
    self._fm.subdir(DIR.IR, mkdir=True)
    self._fm.subdir(DIR.VIS, mkdir=True)

    files = self._fm.raw_files()
    for r, file in utils.ptrack(files, description=&#39;Extracting images...&#39;):
      self._extract_raw_file(file=file)
      yield r</code></pre>
</details>
</dd>
<dt id="pano.interface.pano_project.ThermalPanorama.limit_size"><code class="name flex">
<span>def <span class="ident">limit_size</span></span>(<span>self, image: numpy.ndarray) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def limit_size(self, image: np.ndarray) -&gt; np.ndarray:
  return tools.limit_image_size(image=image, limit=self._size_limit)</code></pre>
</details>
</dd>
<dt id="pano.interface.pano_project.ThermalPanorama.panorama"><code class="name flex">
<span>def <span class="ident">panorama</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def panorama(self):
  spectrum = self._config[&#39;panorama&#39;][&#39;target&#39;].upper()
  if spectrum not in (&#39;IR&#39;, &#39;VIS&#39;):
    raise ValueError(spectrum)

  sopt = self._config[&#39;panorama&#39;][&#39;stitch&#39;]
  stitcher = self._init_stitcher()

  # Raw 파일 추출
  self.extract()

  # 지정한 spectrum 파노라마
  files = self._fm.files(self._SP_DIR[spectrum])
  images = [IIO.read(x) for x in files]

  # 파노라마 생성
  stitcher.set_blend_type(sopt[&#39;blend&#39;][spectrum])
  pano = self._stitch(stitcher=stitcher,
                      images=images,
                      names=[x.stem for x in files],
                      spectrum=spectrum)

  # 저장
  self._save_panorama(spectrum=SP[spectrum], panorama=pano)

  # segmention mask 저장
  stitcher.set_blend_type(False)
  self._stitch_others(stitcher=stitcher, panorama=pano, spectrum=SP.SEG)

  # 나머지 영상의 파노라마 생성/저장
  sp2 = &#39;VIS&#39; if spectrum == &#39;IR&#39; else &#39;IR&#39;
  stitcher.set_blend_type(sopt[&#39;blend&#39;][sp2])
  self._stitch_others(stitcher=stitcher, panorama=pano, spectrum=SP[sp2])

  logger.success(&#39;파노라마 생성 완료&#39;)</code></pre>
</details>
</dd>
<dt id="pano.interface.pano_project.ThermalPanorama.register"><code class="name flex">
<span>def <span class="ident">register</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def register(self):
  self.extract()
  self._fm.subdir(DIR.RGST, mkdir=True)

  files = self._fm.raw_files()
  registrator, prep, matrices = None, None, {}
  for file in utils.track(sequence=files, description=&#39;Registering...&#39;):
    if registrator is None:
      ir = IIO.read(self._fm.change_dir(DIR.IR, file))
      registrator, prep = self._init_registrator(shape=ir.shape)

    matrix = self._register(file=file, registrator=registrator, prep=prep)
    matrices[file.stem] = matrix

  np.savez(self._fm.rgst_matrix_path(), **matrices)
  logger.success(&#39;열화상-실화상 정합 완료&#39;)</code></pre>
</details>
</dd>
<dt id="pano.interface.pano_project.ThermalPanorama.register_generator"><code class="name flex">
<span>def <span class="ident">register_generator</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def register_generator(self):
  self._fm.subdir(DIR.RGST, mkdir=True)

  files = self._fm.raw_files()
  registrator, prep, matrices = None, None, {}
  for r, file in utils.ptrack(sequence=files, description=&#39;Registering...&#39;):
    if registrator is None:
      ir = IIO.read(self._fm.change_dir(DIR.IR, file))
      registrator, prep = self._init_registrator(shape=ir.shape)

    try:
      matrix = self._register(file=file, registrator=registrator, prep=prep)
    except FileNotFoundError as e:
      msg = f&#39;&#34;{e}&#34;를 찾을 수 없습니다. 열화상을 먼저 추출하세요.&#39;
      raise FileNotFoundError(msg) from e

    matrices[file.stem] = matrix

    yield r

  np.savez(self._fm.rgst_matrix_path(), **matrices)
  logger.success(&#39;열화상-실화상 정합 완료&#39;)
  yield 1.0</code></pre>
</details>
</dd>
<dt id="pano.interface.pano_project.ThermalPanorama.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self):
  logger.info(&#39;Start extracting&#39;)
  self.extract()

  logger.info(&#39;Start registering&#39;)
  self.register()

  logger.info(&#39;Start segmenting&#39;)
  self.segment()

  logger.info(&#39;Start panorama stitching&#39;)
  self.panorama()

  logger.info(&#39;Start distortion correction&#39;)
  self.correct()</code></pre>
</details>
</dd>
<dt id="pano.interface.pano_project.ThermalPanorama.segment"><code class="name flex">
<span>def <span class="ident">segment</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def segment(self):
  files, model = self._init_segment_model()

  self._fm.subdir(DIR.SEG, mkdir=True)
  for file in utils.track(files, description=&#39;Segmenting...&#39;):
    self._segment(model, file)

  logger.success(&#39;외피 부위 인식 완료&#39;)</code></pre>
</details>
</dd>
<dt id="pano.interface.pano_project.ThermalPanorama.segment_generator"><code class="name flex">
<span>def <span class="ident">segment_generator</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def segment_generator(self):
  files, model = self._init_segment_model()

  self._fm.subdir(DIR.SEG, mkdir=True)
  for r, file in utils.ptrack(files, description=&#39;Segmenting...&#39;):
    self._segment(model, file)
    yield r

  logger.success(&#39;외피 부위 인식 완료&#39;)
  yield 1.0</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pano.interface" href="index.html">pano.interface</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pano.interface.pano_project.ThermalPanorama" href="#pano.interface.pano_project.ThermalPanorama">ThermalPanorama</a></code></h4>
<ul class="two-column">
<li><code><a title="pano.interface.pano_project.ThermalPanorama.correct" href="#pano.interface.pano_project.ThermalPanorama.correct">correct</a></code></li>
<li><code><a title="pano.interface.pano_project.ThermalPanorama.extract" href="#pano.interface.pano_project.ThermalPanorama.extract">extract</a></code></li>
<li><code><a title="pano.interface.pano_project.ThermalPanorama.extract_generator" href="#pano.interface.pano_project.ThermalPanorama.extract_generator">extract_generator</a></code></li>
<li><code><a title="pano.interface.pano_project.ThermalPanorama.limit_size" href="#pano.interface.pano_project.ThermalPanorama.limit_size">limit_size</a></code></li>
<li><code><a title="pano.interface.pano_project.ThermalPanorama.panorama" href="#pano.interface.pano_project.ThermalPanorama.panorama">panorama</a></code></li>
<li><code><a title="pano.interface.pano_project.ThermalPanorama.register" href="#pano.interface.pano_project.ThermalPanorama.register">register</a></code></li>
<li><code><a title="pano.interface.pano_project.ThermalPanorama.register_generator" href="#pano.interface.pano_project.ThermalPanorama.register_generator">register_generator</a></code></li>
<li><code><a title="pano.interface.pano_project.ThermalPanorama.run" href="#pano.interface.pano_project.ThermalPanorama.run">run</a></code></li>
<li><code><a title="pano.interface.pano_project.ThermalPanorama.segment" href="#pano.interface.pano_project.ThermalPanorama.segment">segment</a></code></li>
<li><code><a title="pano.interface.pano_project.ThermalPanorama.segment_generator" href="#pano.interface.pano_project.ThermalPanorama.segment_generator">segment_generator</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>